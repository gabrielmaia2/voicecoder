DeepIoT: Compressing Deep Neural Network Structures for Sensing Systems with a Compressor-Critic Framework

Shuochao Yao
University of Illinois Urbana Champaign

Yiran Zhao
University of Illinois Urbana Champaign

Aston Zhang
University of Illinois Urbana Champaign

Lu Su
State University of New York at Bu alo

Tarek Abdelzaher
University of Illinois Urbana Champaign

ABSTRACT
Recent advances in deep learning motivate the use of deep neutral networks in sensing applications, but their excessive resource needs on constrained embedded devices remain an important impediment. A recently explored solution space lies in compressing (approximating or simplifying) deep neural networks in some manner before use on the device. We propose a new compression solution, called DeepIoT, that makes two key contributions in that space. First, unlike current solutions geared for compressing speci c types of neural networks, DeepIoT presents a uni ed approach that compresses all commonly used deep learning structures for sensing applications, including fully-connected, convolutional, and recurrent neural networks, as well as their combinations. Second, unlike solutions that either sparsify weight matrices or assume linear structure within weight matrices, DeepIoT compresses neural network structures into smaller dense matrices by nding the minimum number of non-redundant hidden elements, such as lters and dimensions required by each layer, while keeping the performance of sensing applications the same. Importantly, it does so using an approach that obtains a global view of parameter redundancies, which is shown to produce superior compression. e compressed model generated by DeepIoT can directly use existing deep learning libraries that run on embedded and mobile systems without further modi cations. We conduct experiments with ve di erent sensing-related tasks on Intel Edison devices. DeepIoT outperforms all compared baseline algorithms with respect to execution time and energy consumption by a signi cant margin. It reduces the size of deep neural networks by 90% to 98.9%. It is thus able to shorten execution time by 71.4% to 94.5%, and decrease energy consumption by 72.2% to 95.7%. ese improvements are achieved without loss of accuracy. e results underscore the potential of DeepIoT for advancing the exploitation of deep neural networks on resource-constrained embedded devices.
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permi ed. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci c permission and/or a fee. Request permissions from permissions@acm.org. SenSys’17, Del , e Netherlands © 2017 ACM. 978-1-4503-5459-2/17/11. . . $15.00 DOI: 10.1145/3131672.3131675

CCS CONCEPTS
•Human-centered computing →Ubiquitous and mobile computing; •Computing methodologies →Machine learning; •Computer systems organization →Embedded and cyberphysical systems;
KEYWORDS
Deep Learning, Model Compression, Structure Compression, Mobile Computing, Internet of ings
ACM Reference format: Shuochao Yao, Yiran Zhao, Aston Zhang, Lu Su, and Tarek Abdelzaher. 2017. DeepIoT: Compressing Deep Neural Network Structures for Sensing Systems with a Compressor-Critic Framework. In Proceedings of 15th ACM Conference on Embedded Networked Sensor Systems, Del , e Netherlands, November 6–8, 2017 (SenSys’17), 14 pages. DOI: 10.1145/3131672.3131675
1 INTRODUCTION
is paper is motivated by the prospect of enabling a “smarter” and more user-friendly category of every-day physical objects capable of performing complex sensing and recognition tasks, such as those needed for understanding human context and enabling more natural interactions with users in emerging Internet of ings (IoT) applications.
Present-day sensing applications cover a broad range of areas including human interactions [27, 59], context sensing [6, 34, 39, 46, 54], crowd sensing [55, 58], object detection and tracking [7, 29, 42, 53]. e recent commercial interest in IoT technologies promises a proliferation of smart objects in human spaces at a much broader scale. Such objects will ideally have independent means of interacting with their surroundings to perform complex detection and recognition tasks, such as recognizing users, interpre ing voice commands, and understanding human context. e paper explores the feasibility of implementing such functions using deep neural networks on computationally-constrained devices, such as Intel’s suggested IoT platform: the Edison board1.
e use of deep neural networks in sensing applications has recently gained popularity. Speci c neural network models have been designed to fuse multiple sensory modalities and extract temporal relationships for sensing applications. ese models have shown signi cant improvements on audio sensing [31], tracking and localization [8, 38, 52, 56], human activity recognition [37, 56], and user identi cation [31, 56].
1h ps://so ware.intel.com/en-us/iot/hardware/edison

SenSys’17, November 6–8, 2017, Del , The Netherlands

Yao et al.

Training the neural network can occur on a computationally capable node and, as such, is not of concern in this paper. e key impediment to deploying deep-learning-based sensing applications lies in the high memory consumption, execution time, and energy demand associated with storing and using the trained network on the target device. is leads to increased interest in compressing neural networks to enable exploitation of deep learning on low-end embedded devices.
We propose DeepIoT that compresses commonly used deep neural network structures for sensing applications through deciding the minimum number of elements in each layer. Previous illuminating studies on neural network compression sparsify large dense parameter matrices into large sparse matrices [4, 22, 24]. In contrast, DeepIoT minimizes the number of elements in each layer, which results in converting parameters into a set of small dense matrices. A small dense matrix does not require additional storage for element indices and is e ciently optimized for processing [19]. DeepIoT greatly reduces the e ort of designing e cient neural structures for sensing applications by deciding the number of elements in each layer in a manner informed by the topology of the neural network.
DeepIoT borrows the idea of dropping hidden elements from a widely-used deep learning regularization method called dropout [44]. e dropout operation gives each hidden element a dropout probability. During the dropout process, hidden elements can be pruned according to their dropout probabilities. en a “thinned” network structure can be generated. However, these dropout probabilities are usually set to a pre-de ned value, such as 0.5. Such pre-de ned values are not the optimal probabilities, thereby resulting in a less e cient exploration of the solution space. If we can obtain the optimal dropout probability for each hidden element, it becomes possible for us to generate the optimal slim network structure that preserves the accuracy of sensing applications while maximally reducing the resource consumption of sensing systems. An important purpose of DeepIoT is thus to nd the optimal dropout probability for each hidden element in the neural network.
Notice that, dropout can be easily applied to all commonly used neural network structures. In fully-connected neural networks, neurons are dropped in each layer [44]; in convolutional neural networks, lters are dropped in each layer [14]; and in recurrent neural networks, dimensions are reduced in each layer [15]. is means that DeepIoT can be applied to all commonly-used neural network structures and their combinations.
To obtain the optimal dropout probabilities for the neural network, DeepIoT exploits the network parameters themselves. From the perspective of model compression, a hidden element that is connected to redundant model parameters should have a higher probability to be dropped. A contribution of DeepIoT lies in exploiting a novel compressor neural network to solve this problem. It takes model parameters of each layer as input, learns parameter redundancies, and generates the dropout probabilities accordingly. Since there are interconnections of parameters among di erent layers, we design the compressor neural network to be a recurrent neural network that can globally share the redundancy information and generate dropout probabilities layer by layer.
e compressor neural network is optimized jointly with the original neural network to be compressed through a compressor-critic framework that tries to minimize the loss function of the original

sensing applicaiton. e compressor-critic framework emulates the idea of the well-known actor-critic algorithm from reinforcement learning [28], optimizing two networks in an iterative manner.
We evaluate the DeepIoT framework on the Intel Edison computing platform [1], which Intel markets as an enabler platform for the computing elements of embedded “things” in IoT systems. We conduct two sets of experiments. e rst set consists of three tasks that enable embedded systems to interact with humans with basic modalities, including handwri en text, vision, and speech, demonstrating superior accuracy of our produced neural networks, compared to others of similar size. e second set provides two examples of applying compressed neural networks to solving human-centric context sensing tasks; namely, human activity recognition and user identi cation, in a resource-constrained scenario.
We compare DeepIoT with other state-of-the-art magnitudebased [22] and sparse-coding-based [4] neural network compression methods. e resource consumption of resulting models on the Intel Edison module and the nal performance of sensing applications are estimated for all compressed models. In all experiments, DeepIoT is shown to outperform the other algorithms by a large margin in terms of compression ratio, memory consumption, execution time, and energy consumption. In these experiments, when compared with the non-compressed neural networks, DeepIoT is able to reduce the model size by 90% to 98.9%, shorten the running time by 71.4% to 94.5%, and decrease the energy consumption by 72.2% to 95.7%. When compared with the state-out-the-art baseline algorithm, DeepIoT is able to reduce the model size by 11.6% to 83.2%, shorten the running time by 60.9% to 87.9%, and decrease the energy consumption by 64.1% to 88.7%. Importantly, these improvements are achieved without loss of accuracy. Experiments demonstrate the promise of DeepIoT in enabling resource-constrained embedded devices to bene t from advances in deep learning.
e rest of this paper is organized as follows. Section 2 introduces related work on optimizating sensing applications for resourceconstrained devices. We describe the technical details of DeepIoT in Section 3. We describe system implementation in Section 4. e evaluation is presented in Section 5. Finally, we discuss the results in Section 6 and conclude in Section 7.
2 RELATED WORK
A key direction in embedded sensing literaure is to enable running progressively more interesting applications under the more pronounced resource constraints of embedded and mobile devices. Brouwers et al. reduced the energy consumption of Wi-Fi based localization with an incremental scanning strategy [5]. Hester et al. proposed an ultra-low-power hardware architecture and a companion so ware framework for energy-e cient sensing system [25]. Ferrari et al. and Schuss et al. focused on low-power wireless communication protocols [13, 41]. Wang et al. enabled energy e cient reliable broadcast by considering poorly correlated links [49]. Saifullah et al. designed a scalable and energy-e cient wireless sensor network (WSN) over white spaces [40]. Alsheikh et al. discussed about data compression in WSN with machine learning techniques [3].
Recent studies focused on compressing deep neural networks for embedded and mobile devices. Han et al. proposed a magnitudebased compression method with ne-tuning, which illustrated

Compressing Deep Neural Network Structures for Sensing Systems

SenSys’17, November 6–8, 2017, Del , The Netherlands

DeepIoT Original Neural Network

Fully-Connected3

Dropout Layer2

p(2)

Fully-Connected2

Dropout Layer1

p(1)

Fully-Connected1

Parameter2

Compressor Neural Network

W(2)

RNN

W(1)

RNN

Parameter1

Figure 1: Overall DeepIoT system framework. Orange boxes
represent dropout operations. Green boxes represent param-
eters of the original neural network. promising compression results [24]. is method removes weight connections with low magnitude iteratively; however, it requires additional implementation of sparse matrix with more resource consumption. In addition, the aggressive pruning method increases the potential risk of irretrievable network damage. Guo et al. proposed a compression algorithm with connection splicing, which provided the chance of rehabilitation with a certain threshold [22]. However, the algorithm still focuses on weight level instead of structure level. Other than the magnitude-based method, another series of works focused on the factorization-based method that reduced the neural network complexity by exploiting low-rank structures in parameters. Denton et al. exploited various matrix factorization methods with ne-tunning to approximate the convolutional operations in order to reduce the neural network execution time [12]. Lane et al. applied sparse coding based and matrix factorization based method to reduce complexity of fully-connected layer and convolutional layer respectively [4]. However, factorization-based methods usually obtain lower compression ratio compared with magnitude-based methods, and the low-rank assumption may hurt the nal network performance. Wang et al. applied the information of frequency domain for model compression [51]. However, additional implementation is required to speed-up the frequencydomain representations, and the method is not suitable for modern CNNs with small convolution lter sizes. Hinton et al. proposed a teacher-student framework that distilled the knowledge in an ensemble of models into a single model [26]. However, the framework focused more on compressing model ensemble into a single model instead of structure compression.
Our paper is partly inspired by deep reinforcement learning. With the aid of deep neural networks, reinforcement leaning has achieved great success on Atari games [33], Go chess [43], and multichannel access [50].
To the best of our knowledge, DeepIoT is the rst framework for neural network structure compressing based on dropout operations and reducing parameter redundancies, where dropout operations provide DeepIoT the chance of rehabilitation with a certain probability. DeepIoT generates a more concise network structure for transplanting large-scale neural networks onto resource-constrained embedded devices.
3 SYSTEM FRAMEWORK
We introduce DeepIoT, a neural network structure compression framework for sensing applications. Without loss of generality,

before introducing the technical details, we rst use an example of compressing a 3-layer fully-connected neural network structure to illustrate the overall pipeline of DeepIoT. e detailed illustration is shown in Figure 1. e basic steps of compressing neural network structures for sensing applications with DeepIoT can be summarized as follows.
(1) Insert operations that randomly zeroing out hidden elements with probabilities p(l) called dropout (red boxes in Figure 1) into internal layers of the original neural network. e internal layers exclude input layers and output layers that have the xed dimension for a sensing application. is step will be detailed in Section 3.1.
(2) Construct the compressor neural network. It takes the weight matrices W(l) (green boxes in Figure 1) from the layers to be compressed in the original neural network as inputs, learns and shares the parameter redundancies among di erent layers, and generates optimal dropout probabilities p(l), which is then fed back to the dropout operations in the original neural network. is step will be detailed in Section 3.2.
(3) Iteratively optimize the compressor neural network and the original neural network with the compressor-critic framework. e compressor neural network is optimized to produce be er dropout probabilities that can generate a more e cient network structure for the original neural network. e original neural network is optimized to achieve a be er performance with the more e cient structure for a sensing application. is step will be detailed in Section 3.3.
For the rest of this paper, all vectors are denoted by bold lowercase le ers (e.g., x and y), and matrices and tensors are represented by bold upper-case le ers (e.g., X and Y). For a column vector x, the jth element is denoted by x[j]. For a tensor X, the tth matrix along the third axis is denoted by X··t , and the other slicing denotations are de ned similarly. e superscript l in x(l) and X(l) denote the vector and tensor for the lth layer of the neural network. We use calligraphic le ers to denote sets (e.g., X and Y). For any set X, |X| denotes the cardinality of X.

3.1 Dropout Operations in the Original Neural
Network
Dropout is commonly used as a regularization method that prevents feature co-adapting and model over ing. e term “dropout” refers to dropping out units (hidden and visible) in a neural network. Since DeepIoT is a structure compression framework, we focus mainly on dropping out hidden units. e de nitions of hidden units are distinct in di erent types of neural networks, and we will describe them in detail. e basic idea is that we regard neural networks with dropout operations as bayesian neural networks with Bernoulli variational distributions [14, 15, 44].
For the fully-connected neural networks, the fully-connected operation with dropout can be formulated as

z([lj

) ]

∼

Bernoulli(p([lj)]),

W˜ (l ) = W(l )diag z(l ) , (1)
Y(l ) = X(l )W˜ (l ) + b(l ),

X(l +1) = f Y(l ) .

SenSys’17, November 6–8, 2017, Del , The Netherlands

Yao et al.

Refer to (1). e notation l = 1, · · · , L is the layer number in

the fully-connected neural network. For any layer l, the weight

matrix is denoted as W(l ) ∈ Rd(l−1)×d(l) ; the bias vector is denoted as b(l ) ∈ Rd(l) ; and the input is denoted as X(l ) ∈ R1×d(l−1) . In

addition, f (·) is a nonlinear activation function.

As shown in (1), each hidden unit is controlled by a Bernoulli

random variable. In the original dropout method, the success prob-

abilities

of

p([lj

) ]

can

be

set

to

the

same

constant

p

for

all

hidden

units [44], but DeepIoT uses the Bernoulli random variable with

individual success probabilities for di erent hidden units in order

to compress the neural network structure in a ner granularity.

For the convolutional neural networks, the basic fully-connected

operation is replaced by the convolution operation [14]. However,

the convolution can be reformulated as a linear operation as shown

in (1). For any layer l, we denote K(l) = Kk(l) for k = 1, · · · , c(l) as the set of convolutional neural network (CNN)’s kernels, where Kk(l ) ∈ Rh(l)×w(l)×c(l−1) is the kernel of CNN with height h(l ), width w(l), and channel c(l−1). e input tensor of layer l is denoted as Xˆ (l ) ∈ Rhˆ(l−1)×wˆ (l−1)×c(l−1) with height hˆ(l −1), width wˆ (l −1), and
channel c(l −1).

Next, we convert convolving the kernels with the input into per-

forming matrix product. We extract h(l) × w(l) × c(l−1) dimensional

patches from the input Xˆ (l) with stride s and vectorize them. Collect

these vectorized n patches to be the rows of our new input repre-

sentation X(l ) ∈ Rn×(h(l)w(l)c(l−1)). e vectorized kernels form the columns of the weight matrix W(l ) ∈ R(h(l)w(l)c(l−1))×c(l) .

With this transformation, dropout operations can be applied to

convolutional neural networks according to (1). e composition of

pooling and activation functions can be regarded as the nonlinear

function f (·) in (1). Instead of dropping out hidden elements in

each layer, we drop out convolutional kernels in each layer. From

the perspective of structure compression, DeepIoT tries to prune

the number of kernels used in the convolutional neural networks.

For the recurrent neural network, we take a multi-layer Long

Short Term Memory network (LSTM) as an example. e LSTM

operation with dropout can be formulated as

z([lj

) ]

∼

Bernoulli(p([lj)]),

i sigm

f o g

=

sigm sigm tanh

W(l )

h(tl −1) h(tl−)1

z(l −1) z(l )

,

(2)

c(tl ) = f h(tl ) = o

c(tl−)1 + i g, tanh c(tl ) .

e notation l = 1, · · · , L is the layer number and t = 1, · · · ,T
is the step number in the recurrent neural network. Element-wise
multiplication is denoted by . Operators si m and tanh denote
sigmoid function and hyperbolic tangent respectively. e vector ht(l) ∈ Rn(l) is the output of step t at layer l. e vector ht(0) = xt is the input for the whole neural network at step t. e matrix W(l ) ∈ R4n(l)×(n(l−1)+n(l)) is the weight matrix at layer l . We let p([0j]) = 1, since DeepIoT only drops hidden elements.

As shown in (2), DeepIoT uses the same vector of Bernoulli random variables z(l) to control the dropping operations among di erent time steps in each layer, while individual Bernoulli random variables are used for di erent steps in the original LSTM dropout [57]. From the perspective of structure compression, DeepIoT tries to prune the number of hidden dimensions used in LSTM blocks. e dropout operation of other recurrent neural network architectures, such as Gated Recurrent Unit (GRU), can be designed similarly.

3.2 Compressor Neural Network
Now we introduce the architecture of the compressor neural net-
work. As we described in Section 1, a hidden element in the original
neural network that is connected to redundant model parameters
should have a higher probability to be dropped. erefore we design
the compressor neural network to take the weights of an original neural network {W(l)} as inputs, learn the redundancies among these weights, and generate dropout probabilities {p(l)} for hidden
elements that can be eventually used to compress the original neural
network structure.
A straightforward solution is to train an individual fully-
connected neural network for each layer in the original neural
network. However, since there are interconnections among weight
redundancies in di erent layers, DeepIoT uses a variant LSTM as the
structure of compressor to share and use the parameter redundancy
information among di erent layers.
According to the description in Section 3.1, the weight in layer
l of fully-connected, convolutional, or recurrent neural network can all be represented as a single matrix W(l ) ∈ Rdf(l)×dd(lr)op , where dd(lr)op denotes the dimension that dropout operation is applied and df(l) denotes the dimension of features within each dropout element. Here, we need to notice that the weight matrix of LSTM at layer l can be reshaped as W(l ) ∈ R4·(n(l−1)+n(l))×n(l) , where dd(lr)op = n(l ) and df(l) = 4 · (n(l−1) + n(l)). Hence, we take weights from the original network layer by layer, W = W(l) with l = 1, · · · , L,
as the input of the compressor neural network. Instead of using a
vanilla LSTM as the structure of compressor, we apply a variant
l-step LSTM model shown as

vi

vf vo

= Wc(l )W(l )Wi(l ),

v

ui

uf uo

= Wh hl −1,

u

i sigm vi ui

f o

=

sigm sigm

vf + uf , vo uo

(3)

g tanh v

u

cl = f cl −1 + i g,

hl = o tanh cl ,

p(l ) = pt = sigm Wo(l )hl ,

z([lj

) ]

∼

Bernoulli(p([lj)]).

Refer to (3), we denote dc as the dimension of the variant LSTM

hidden state.

en W(l ) ∈ Rdf(l)×dd(lr)op , Wc(l ) ∈ R4×df(l) , Wi(l ) ∈

Rdd(lr)op×dc , Wh ∈ R4dc ×dc , and Wo(l ) ∈ Rdd(lr)op×dc . e set of training

Compressing Deep Neural Network Structures for Sensing Systems

SenSys’17, November 6–8, 2017, Del , The Netherlands

parameters of the compressor neural network is denoted as ϕ, where ϕ = Wc(l), Wi(l), Wh , Wo(l) . e matrix W(l) is the input matrix for step l in the compressor neural network, which is also the lth layer’s parameters of the original neural network in (1) or (2).
Compared with the vanilla LSTM that requires vectorizing the original weight matrix as inputs, the variant LSTM model preserves the structure of original weight matrix and uses less learning parameters to extract the redundancy information among the dropout elements. In addition, Wc(l) and Wi(l) convert original weight matrix W(l) with di erent sizes into xed-size representations. e binary vector z(l) is the dropout mask and probability p(l) is the dropout probabilities for the lth layer in the original neural network used in (1) and (2), which is also the stochastic dropout policy learnt through observing the weight redundancies of the original neural network.
3.3 Compressor-Critic Framework
In Section 3.1 and Section 3.2, we have introduced customized dropout operations applied on the original neural networks that need to be compressed and the structure of compressor neural network used to learn dropout probabilities based on parameter redundancies. In this subsection, we will discuss the detail of compressorcritic compressing process. It optimizes the original neural network and the compressor neural network in an iterative manner and enables the compressor neural network to gradually compress the original neural network with so deletion.
We denote the original neural network as FW (x|z), and we call it critic. It takes x as inputs and generates predictions based on binary dropout masks z and model parameters W that refer to a set of weights W = {W(l)} . We assume that FW (x|z) is a pre-trained model. We denote the compressor neural network by z ∼ µϕ (W). It takes the weights of the critic as inputs and generates the probability distribution of the mask vector z based on its own parameters ϕ. In order to optimize the compressor to drop out hidden elements in the critic, DeepIoT follows the objective function

L = Ez∼µϕ L y, FW (x |z)

=

µϕ (W) · L y, FW (x |z) ,

(4)

z∼{0, 1}|z|

where L(·, ·) is the objective function of the critic. e objective function can be interpreted as the expected loss of the original neural network over the dropout probabilities generated by the compressor.
DeepIoT optimizes the compressor and critic in an iterative manner. It reduces the expected loss as de ned in (4) by applying the gradient descent method on compressor and critic iteratively. However, since there are discrete sampling operations, i.e., dropout operations, within the computational graph, backpropagation is not directly applicable. erefore we apply an unbiased likelihood-ratio estimator to calculate the gradient over ϕ [17, 36]:

∇ϕ L = ∇ϕ µϕ (W) · L y, FW (x |z)
z

= µϕ (W)∇ϕ log µϕ (W) · L y, FW (x |z)

(5)

z

= Ez∼µϕ ∇ϕ log µϕ (W) · L y, FW (x |z) .

erefore an unbiased estimator for (5) can be

∇ϕ L = ∇ϕ log µϕ (W) · L y, FW (x |z) z ∼ µϕ .

(6)

e gradient over W(l) ∈ W is

∇W(l) L = µϕ (W) · ∇W(l) L y, FW (x |z)

z

(7)

= Ez∼µϕ ∇W(l) L y, FW (x |z) .

Similarly, an unbiased estimator for (7) can be

∇W(l) L = ∇W(l) L y, FW (x |z) z ∼ µϕ .

(8)

Now we provide more details of ∇ϕ L in (6). Although the estimator (6) is an unbiased estimator, it tends to have a higher variance. A higher variance of estimator can make the convergence slower.
erefore, variance reduction techniques are typically required to make the optimization feasible in practice [21, 32].
One variance reduction technique is to subtract a constant c from learning signal L y, FW (x|z) in (5), which still keeps the expectation of the gradient unchanged [32]. erefore, we keep track of the moving average of the learning signal L y, FW (x|z) denoted by c, and subtract c from the gradient estimator (6).
e other variance reduction technique is keeping track of the moving average o√f the signal variance , and divides the learning signal by max(1, ) [21].
Combing the aforementioned two variance reduction techniques, the nal estimator (6) for gradient over ϕ becomes

∇ϕ L

=

∇ϕ

log µϕ (W) ·

L

y, FW (x |z) − c √
max(1, )

z ∼ µϕ,

(9)

where c and are the moving average of mean and the moving average of variance of learning signal L y, FW (x|z) respectively.
A er introducing the basic optimization process in DeepIoT, now we are ready to deliver the details of the compressing process. Compared with previous compressing algorithms that gradually delete weights without rehabilitation [24], DeepIoT applies “so ” deletion by gradually suppressing the dropout probabilities of hidden elements with a decay factor γ ∈ (0, 1). During the experiments in Section 5, we set γ as the default value 0.5. Since it is impossible to make the optimal compression decisions from the beginning, suppressing the dropout probabilities instead of deleting the hidden elements directly can provide the “deleted” hidden elements changes to recover. is less aggressive compression process reduces the potential risk of irretrievable network damage and learning ine ciency.
During the compressing process, DeepIoT gradually increases the threshold of dropout probability τ from 0 with step ∆. e hidden elements with dropout probability, p([lj)] that is less than the threshold τ will be given decay on dropout probability, i.e., pˆ([lj)] ← γ · p([lj)].
erefore, the operation in compressor (3) can be updated as

z([lj

) ]

∼

Bernoulli

p([lj)] · γ 1p([lj)] ≤τ

,

(10)

where 1 is the indicator function; γ ∈ (0, 1) is the decay factor;
and τ ∈ [0, 1) is the threshold. Since the operation of suppressing dropout probability with the pre-de ned decay factor γ is di erentiable, we can still optimize the original and the compressor neural network through (8) and (9). e compression process will stop

SenSys’17, November 6–8, 2017, Del , The Netherlands

Yao et al.

Algorithm 1 Compressor-predictor compressing process

1: Input: pre-trained predictor FW (x |z) 2: Initialize: compressor µϕ (W) with parameter ϕ, moving average c, moving

average of variance

3: while µϕ (W) is not convergent do

4: z ∼ µϕ (W)

5: c ← movingAvg L y, FW (x |z)

6:

← movingVar L y, FW (x |z)

√

7: ϕ ← ϕ − β · ∇ϕ log µϕ (W) · L y, FW (x |z) − c /max(1, )

8: end while

9: τ = 0

10: while the percentage of le number of parameters in FW (x |z) is larger than α

do

11: z ∼ µϕ (W)

12: c ← movingAvg L y, FW (x |z)

13:

← movingVar L y, FW (x |z)

√

14: ϕ ← ϕ − β · ∇ϕ log µϕ (W) · L y, FW (x |z) − c /max(1, )

15: W ← W − β · ∇W L y, FW (x |z)

16: update threshold τ : τ ← τ + ∆ for every T rounds

17: end while

18:

zˆ[(lj)]

=

1p([lj

) ]

>τ

19: while FW (x |zˆ) is not convergent do

20: W ← W − β · ∇W L y, FW (x |zˆ)

21: end while

when the percentage of le number of parameters in FW (x|z) is smaller than a user-de ned value α ∈ (0, 1).
A er the compression, DeepIoT ne-tunes the compressed model FW (x|zˆ), with a xed mask zˆ, which is decided by the previous threshold τ . erefore the mask generation step in (10) will be updated as

zˆ([lj)] = 1p([lj)] > τ .

(11)

We summarize the compressor-critic compressing process of DeepIoT in Algorithm 1.
e algorithm consists of three parts. In the rst part (Line 3 to Line 8), DeepIoT freezes the critic FW (x|z) and initializes the compressor µϕ (W) according to (9). In the second part (Line 9 to Line 17), DeepIoT optimizes the critic and compressor jointly with the gradients calculated by (8) and (9). At the same time, DeepIoT gradually compresses the predictor by suppressing dropout probabilities according to (10). In the nal part (Line 18 to Line 21), DeepIoT ne-tunes the critic with the gradient calculated by (8) and a deterministic dropout mask is generated according to (11). A er these three phases, DeepIoT generates a binary dropout mask zˆ and the ne-tuning parameters of the critic W. With these two results, we can easily obtain the compressed model of the original neural network.

4 IMPLEMENTATION
In this section, we brie y describe the hardware, so ware, architecture, and performance summary of DeepIoT.
4.1 Hardware
Our hardware is based on Intel Edison computing platform [1]. e Intel Edison computing platform is powered by the Intel Atom SoC dual-core CPU at 500 MHz and is equipped with 1GB memory and 4GB ash storage. For fairness, all neural network models are run solely on CPU during experiments.

4.2 So ware
All the original neural networks for all sensing applications mentioned in Section 5 are trained on the workstation with NVIDIA GeForce GTX Titan X. For all baseline algorithms mentioned in Section 5, the compressing processes are also conducted on the workstation. e compressed models are exported and loaded into the ash storage on Intel Edison for experiments.
We installed the Ubilinux operation system on Intel Edison computing platform [2]. Far fairness, all compressed deep learning models are run through eano [48] with only CPU device on Intel Edison. e matrix multiplication operations and sparse matrix multiplication operations are optimized by BLAS and Sparse BLAS respectively during the implementation. No additional run-time optimization is applied for any compressed model and in all experiments.
4.3 Architecture
Given the original neural network structure and parameters as well as the device resource information, DeepIoT can automatically generate a compressed neural network that is ready to be run on embedded devices with sensor inputs. e system rst obtains the memory information from the embedded device and sets the nal compressed size of the neural network to t in a pre-con gured fraction of available memory, from which the needed compression ratio is computed. In the experiments, we manually set the ratio to exploit the capability of DeepIoT. is ratio, together with the parameters of the original model are then used to automatically generate the corresponding compressor neural network to compress the original neural network. e resulting compressed neural network is transferred to the embedded device. is model can be then called locally with a data input to decide on the output. e semantics of input and output are not known to the model.
4.4 Performance Summary
We list the resource consumption numbers of all compressed models without loss of accuracy generated by DeepIoT and their corresponding original model in Table 1 with the form of (original/compressed/reduction percentage). ese models are explained in more detail in the evaluation, Section 5.

Table 1: Resource consumptions of model implementations on Intel Edison

Model
LeNet5 VGGNet Bi-LSTM DeepSense1 DeepSense2

Size (MB)
1.72/0.04/97.6% 118.8/2.9/97.6% 76.0/7.59/90.0% 1.89/0.12/93.7% 1.89/0.02/98.9%

Time (ms)
50.2/14.2/71.4% 1.5K /82.2/94.5% 71K /9.6K /86.5% 130/36.7/71.8% 130/25.1/80.7%

Energy (mJ)
47.1/12.5/73.5% 1.7K /74/95.6% 62.9K /8.1K /87.1% 99.6/27.7/72.2% 105.1/18.1/82.8%

Although the models generated by DeepIoT do not use sparse matrix representations, other baseline algorithms, as will be introduced in Section 5, may use sparse matrices to represent models. When the proportion of non-zero elements in the sparse matrix is larger than 20%, sparse matrix multiplications can even run slower than their non-sparse counterpart. erefore, there is a tradeo between memory consumption and execution time for sparse matrices with a large proportion of non-zero elements. In addition, convolution

Compressing Deep Neural Network Structures for Sensing Systems

SenSys’17, November 6–8, 2017, Del , The Netherlands

operations conducted on CPU are also formulated and optimized as matrix multiplications, as mentioned in Section 3.1. erefore, the tradeo still exists. For all baseline algorithms in Section 5, we implement both the sparse matrix version and the non-sparse matrix version. During all the experiments with baseline algorithms, we “cheat”, in their favor, by choosing the version that performs be er according to the current evaluation metrics.
5 EVALUATION
In this section, we evaluate DeepIoT through two sets of experiments. e rst set is motivated by the prospect of enabling future smarter embedded “things” (physical objects) to interact with humans using user-friendly modalities such as visual cues, handwri en text, and speech commands, while the second evaluates human-centric context sensing, such as human activity recognition and user identi cation. In the following subsections, we rst describe the comparison baselines that are current state of the art deep neural network compression techniques. We then present the
rst set of experiments that demonstrate accuracy and resource demands observed if IoT-style smart objects interacted with users via natural human-centric modalities thanks to deep neural networks compressed, for the resource-constrained hardware, with the help of our DeepIoT framework. Finally, we present the second set of experiments that demonstrate accurancy and resource demands when applying DeepIoT to compress deep neural networks trained for human-centric context sensing applications. In both cases, we show signi cant advantages in the accuracy/resource trade-o over the compared state-of-the-art compression baselines.
5.1 Baseline Algorithms
We compare DeepIoT with other three baseline algorithms:
(1) DyNS: is is a magnitude-based network pruning algorithm [22]. e algorithm prunes weights in convolutional kernels and fully-connected layer based on the magnitude. It retrains the network connections a er each pruning step and has the ability to recover the pruned weights. For convolutional and fully-connected layers, DyNS searches the optimal thresholds separately.
(2) SparseSep: is is a sparse-coding and factorization based algorithm [4]. e algorithm simpli es the fully-connected layer by nding the optimal code-book and code based on a sparse coding technique. For the convolutional layer, the algorithm compresses the model with matrix factorization methods. We greedily search for the optimal code-book and factorizaiton number from the bo om to the top layer.
(3) DyNS-Ext: e previous two algorithms mainly focus on compressing convolutional and fully-connected layers. erefore we further enhance and extend the magnitude-based method used in DyNS to recurrent layers and call this algorithm DyNSExt. Just like DeepIoT, DyNS-Ext can be applied to all commonly used deep network modules, including fully-connected layers, convolutional layers, and recurrent layers. If the network structure does not contain recurrent layers, we apply DyNS instead of DyNS-Ext.
For magnitude-based pruning algorithms, DyNS and DyNS-Ext, hidden elements with zero input connections or zero output connections will be pruned to further compress the network structure. In addition, all models use 32-bit oats without any quantization.

5.2 Supporting Human-Centric Interaction
Modalities
ree basic interaction modalities among humans are text, vision, and speech. In this section, we describe three di erent experiments that test implementations of these basic interaction modalities on low-end devices using trained and compressed neural networks. We train state-of-art neural networks on traditional benchmark datasets as original models. en, we compress the original models using DeepIoT and the three baseline algorithms described above. Finally, we test the accuracy and resource consumption that result from using these compressed models on the embedded device.
5.2.1 Handwri en digits recognition with LeNet5. e rst human interaction modality is recognizing handwri en text. In this experiment, we consider a meaningful subset of that; namely recognizing handwri en digits from visual inputs. An example application that uses this capability might be a smart wallet equipped with a camera and a tip calculator. We use MNIST2 as our training and testing dataset. e MNIST is a dataset of handwri en digits that is commonly used for training various image processing systems. It has a training set of 60000 examples, and a test set of 10000 examples.
We test our algorithms and baselines on the LeNet-5 neural network model. e corresponding network structure is shown in Table 2. Notice that we omit all the polling layers in Table 2 for simplicity, because they do not contain training parameters.
e rst column of Table 2 represents the network structure of LeNet-5, where “convX” represents the convolutional layer and “fcY” represents the fully-connected layer. e second column represents the number of hidden units or convolutional kernels we used in each layer. e third column represents the number of parameters used in each layer and in total. e original LeNet-5 is trained and achieves an error rate of 0.85% in the test dataset.
We then apply DeepIoT and two other baseline algorithms, DyNS and SparseSep, to compress LeNet-5. Note that, we do not use DyNSExt because the network does not contain a recurrent layer. e network statistics of the compressed model are shown in Table 2. DeepIoT is designed to prune the number of hidden units for a more e cient network structure. erefore, we illustrate both the remaining number of hidden units and the proportion of the remaining number of parameters in Table 2. Both DeepIoT and DyNS can signi cantly compress the network without hurting the nal performance. SparseSep shows an acceptable drop of performance.
is is because SparseSep is designed without ne-tuning. It has the bene t of not ne-tuning the model, but it su ers the loss in the nal performance at the same time.
e detailed tradeo between testing accuracy and memory consumption by the model is illustrated in Fig 2a. We compress the original neural network with di erent compression ratios and recode the nal testing accuracy. In the zoom-in illustration, DeepIoT achieves at least ×2 be er tradeo compared with the two baseline methods. is is mainly due to two reasons. One is that the compressor neural network in DeepIoT obtains a global view of parameter redundancies and is therefore be er capable of eliminating them.
e other is that DeepIoT prunes the hidden units directly, which
2h p://yann.lecun.com/exdb/mnist/

SenSys’17, November 6–8, 2017, Del , The Netherlands

Yao et al.

Layer
conv1 (5 × 5) conv2 (5 × 5)
fc1 fc2 total
Test Error

Table 2: LeNet5 on MNIST dataset

Hidden Units 20 50 500 10
0.85%

Params
0.5K 25K 400K 5K 431K

DeepIoT (Hidden Units/ Params)

10

50.0%

20

20.0%

10

0.8%

10

2.0%

1.98%

0.85%

DyNS
24.2% 20.7% 1.0% 16.34% 2.35%
0.85%

SparseSep
84% 91% 78.75% 70.28% 72.39%
1.05%

100

DeepIoT

100

100 DeepIoT

DeepIoT

DyNS

DyNS

DyNS

SparseSep

SparseSep

SparseSep

80

80

80

Accuracy (%) Accuracy (%) Accuracy (%)

100

60

80

60

40

40

200

0.02

0.04

0.06

0.08

0.1

200

0.2

0.4

0.6

0.8

1

Proportion of memory consumption by the model

60

40

20

10

100

80

60

40

206

8

10

12

14

20

30

40

50

Execution Time (ms)

60

40

20

10

100

80

60

40

204

6

8

10

12

14

20

30

40

50

Inference Energy (mJ)

(a) e tradeo between testing accuracy and(b) e tradeo between testing accuracy and (c) e tradeo between testing accuracy and

memory consumption by models.

execution time.

energy consumption.

Figure 2: System performance tradeo for LeNet5 on MNIST dataset

enables us to represent the compressed model parameters with a small dense matrix instead of a large sparse matrix. e sparse matrix consumes more memory for the indices of matrix elements. Algorithms such as DyNS generate models represented by sparse matrices that cause larger memory consumption.
e evaluation results on execution time of compressed models on Intel Edison, are illustrated in Fig. 2b. We run each compressed model on Intel Edison for 5000 times and use the mean value for generating the tradeo curves.
DeepIoT still achieves the best tradeo compared with other two baselines by a signi cant margin. DeepIoT takes 14.2ms to make a single inference, which reduces execution time by 71.4% compared with the original network without loss of accuracy. However SparseSep takes less execution time compared with DyNS at the cost of acceptable performance degradation (around 0.2% degradation on test error). e main reason for this observation is that, even though fully-connected layers occupy the most model parameters, most execution time is used by the convolution operations. SparseSep uses a matrix factorization method to covert the 2d convolutional kernel into two 1d convolutional kernels on two di erent dimensions [47]. Although this method makes low-rank assumption on convolutional kernel, it can speed up convolution operations if the size of convolutional kernel is large (5 × 5 in this experiment). It can sometimes speed up the operation even when two 1d kernels have more parameters in total compared with the original 2d kernel. However DyNS applies a magnitude-based method that prunes most of the parameters in fully-connected layers. For convolutional layers, DyNS does not reduce the number of convolutional operations e ectively, and sparse matrix multiplication is less e cient compared with regular matrix with the same number of elements. DeepIoT directly reduces the number of convolutional kernels in each layer, which reduces the number of operations in convolutional

layers without making the low-rank assumption that can hurt the network performance.
e evaluation of energy consumption on Intel Edison is illustrated in Fig. 2c. For each compressed model, we run it for 5000 times and measure the total energy consumption by a power meter.
en, we calculate the expected energy consumption for one-time execution and use the one-time energy consumption to generate the tradeo curves in Fig. 2c.
Not surprisingly, DeepIoT still achieves the best tradeo in the evaluation on energy consumption by a signi cant margin. It reduces energy consumption by 73.7% compared with the original network without loss of accuracy. Being similar as the evaluation on execution time, energy consumption focuses more on the number of operations than the model size. erefore, SparseSep can take less energy consumption compared with DyNS at the cost of acceptable loss on performance.
5.2.2 Image recognition with VGGNet. e second human interaction modality is through vision. During this experiment, we use CIFAR103 as our training and testing dataset. e CIFAR-10 dataset consists of 60000 32x32 colour images in 10 classes, with 6000 images per class. ere are 50000 training images and 10000 test images. It is a standard testing benchmark dataset for the image recognition tasks. While not necessarily representative of seeing objects in the wild, it o ers a more controlled environment for an apples-to-apples comparison.
During this evaluation, we use the VGGNet structure as our original network structure. It is a huge network with millions of parameters. VGGNet is chosen to show that DeepIoT is able to compress relative deep and large network structure. e detailed structure is shown Table 3.
3h ps://www.kaggle.com/c/cifar-10

Compressing Deep Neural Network Structures for Sensing Systems

SenSys’17, November 6–8, 2017, Del , The Netherlands

Layer
conv1 (3 × 3) conv2 (3 × 3) conv3 (3 × 3) conv4 (3 × 3) conv5 (3 × 3) conv6 (3 × 3) conv7 (3 × 3) conv8 (3 × 3) conv9 (3 × 3) conv10 (3 × 3) conv11 (2 × 2) conv12 (2 × 2) conv13 (2 × 2)
fc1 fc2 fc3
total
Test Accuracy

Table 3: VGGNet on CIFAR-10 dataset

Hidden Units

Params DeepIoT (Hidden Units/ Params)

64

1.7K

27

64

36.9K

47

128

73.7K

53

128

147.5K

68

256

294.9K

104

256

589.8K

97

256

589.8K

89

512

1.179M

122

512

2.359M

95

512

2.359M

64

512

1.049M

128

512

1.049M

112

512

1.049M

149

4096

2.097M

27

4096

16.777M

371

10

41K

10

29.7M

42.2% 31.0% 30.4% 22.0% 21.6% 15.4% 13.2% 8.3% 4.4% 2.3% 3.1% 5.5% 6.4% 0.19% 0.06% 9.1%
2.44%

90.6%

90.6%

DyNS
53.9% 40.1% 52.3% 67.0% 71.2% 65.0% 61.2% 36.5% 10.6% 3.9% 3.0% 1.7% 2.4% 2.2% 0.39% 18.5%
7.05%
90.6%

SparseSep
93.1% 57.3% 85.1% 56.8% 85.1% 56.8% 56.8% 85.2% 56.8% 56.8% 85.2% 85.2% 85.2% 95.8% 135% 90.2%
112%
87.1%

100

100

100

90

80

80

80

Accuracy (%) Accuracy (%) Accuracy (%)

70

60

60

60

40

50

DeepIoT

DyNS

SparseSep

40 0

0.2

0.4

0.6

0.8

1

1.2

200

Proportion of memory consumption by the model

500

1000

Execution Time (ms)

DeepIoT DyNS SparseSep
1500

40

DeepIoT

DyNS

SparseSep

200

500

1000

1500

Inference Energy (mJ)

(a) e tradeo between testing accuracy and(b) e tradeo between testing accuracy and (c) e tradeo between testing accuracy and

memory consumption by models.

execution time.

energy consumption.

Figure 3: System performance tradeo for VGGNet on CIFAR-10 dataset

In Table 3, we illustrate the detailed statistics of best compressed model that keeps the original testing accuracy for three algorithms. We clearly see that DeepIoT beats the other two baseline algorithms by a signi cant margin. is shows that the compressor in DeepIoT can handle networks with relatively deep structure. e compressor uses a variant of the LSTM architecture to share the redundancy information among di erent layers. Compared with other baselines considering only local information within each layer, sharing the global information among layers helps us learn about the parameter redundancy and compress the network structure. In addition, we observe performance loss in the compressed network generated by SparseSep. It is mainly due to the fact that SparseSep avoids the
ne-tuning step. is experiment shows that ne-tuning (Line 18 to Line 21 in Algorithm 1) is important for model compression.
Fig. 3a shows the tradeo between testing accuracy and memory consumption for di erent models. DeepIoT achieves a be er performance by even a larger margin, because the model generated by DeepIoT can still be represented by a standard matrix, while other methods that use a sparse matrix representation require more memory consumption.
Fig. 3b shows the tradeo between testing accuracy and execution time for di erent models. DeepIoT still achieves the best tradeo . DeepIoT takes 82.2ms for a prediction, which reduces 94.5% execution time without the loss of accuracy. Di erent from the experiment with LeNet-5 on MNIST, DyNS uses less execution

time compared with SparseSep in this experiment. ere are two reasons for this. One is that VGGNet use smaller convolutional kernel compared with LeNet-5. erefore factorizing 2d kernel into two 1d kernel helps less on reducing computation time. e other point is that SparseSep fails to compress the original network into a small size while keeping the original performance. As we mentioned before, it is because SparseSep avoids the ne-tuning.
Fig. 3c shows the tradeo between testing accuracy and energy consumption for di erent models. DeepIoT reduces energy consumption by 95.7% compared with the original VGGNet without loss of accuracy. It greatly helps us to develop a long-standing application with deep neural network in energy-constrained embedded devices.
5.2.3 Speech recognition with deep Bidirectional LSTM. e third human interaction modality is speech. e sensing system can take the voices of users from the microphone and automatically convert what users said into text. e previous two experiments mainly focus on the network structure with convolutional layers and fullyconnected layers. We see how DeepIoT and the baseline algorithms work on the recurrent neural network in this section.
In this experiment, we use LibriSpeech ASR corpus [35] as our training and testing dataset. e LibriSpeech ASR corpus is a largescale corpus of read English speech. It consists of 460-hour training data and 2-hour testing data.

SenSys’17, November 6–8, 2017, Del , The Netherlands

Yao et al.

Table 4: Deep bidirectional LSTM on LibriSpeech ASR corpus

Layer

Hidden Unit

Params

DeepIoT (Hidden Units/ Params) DyNS-Ext

LSTMf1 LSTMb1 LSTMf2 LSTMb2 LSTMf3 LSTMb3 LSTMf4 LSTMb4 LSTMf5 LSTMb5
fc1
total

512 512

512

512

512

512

512

512

512

512

29

1.090M 1.090M 2.097M 2.097M 2.097M 2.097M 2.097M 2.097M 2.097M 2.097M
59.3K
19.016M

55 20 192 71 240 76 258 81 294 90
29

10.74% 3.91% 4.03% 0.54% 17.58% 2.06% 23.62% 2.35% 28.93% 2.78%
37.5%
9.98%

34.9% 18.2% 37.2% 23.1% 43.1% 27.9% 52.3% 40.2% 72.6% 61.8%
69.0%
37.1%

Word error rate (WER)

9.31

9.20

9.62

35 DeepIoT DyNS−Ext
30

35

35

DeepIoT

DeepIoT

DyNS−Ext

DyNS−Ext

30

30

Word Error Rate Word Error Rate Word Error Rate

25

25

25

20

20

20

15

15

15

10

10

10

50

0.2

0.4

0.6

0.8

1

Proportion of memory consumption by the model

50

20

40

60

80

Execution Time (s)

50

10 20 30 40 50 60 70

Inference Energy (J)

(a) e tradeo between word error rate and(b) e tradeo between word error rate and (c) e tradeo between word error rate and

memory consumption by models.

execution time.

energy consumption.

Figure 4: System performance tradeo for deep bidirectional LSTM on LibriSpeech ASR corpus

We choose deep bidirectional LSTM as the original model [20] in this experiment. It takes mel frequency cepstral coe cient (MFCC) features of voices as inputs, and uses two 5-layer long short-term memory (LSTM) in both forward and backward direction. e output of two LSTM are jointly used to predict the spoken text. e detailed network structure is shown in the rst column of Table 4, where “LSTMf” denotes the LSTM in forward direction and “LSTMb” denotes the LSTM in backward direction.
Two baseline algorithms are not applicable to the recurrent neural network, so we compared DeepIoT only with SyNS-Ext in this experiment. e word error rate (WER), de ned as the edit distance between the true word sequence and the most probable word sequence predicted by the neural network, is used as the evaluation metric for this experiment.
We show the detailed statistics of best compressed model that keeps the original WER in Table 4. DeepIoT achieves a signi cantly be er compression rate compared with DyNS-Ext, and the model generated by DeepIoT even has a li le improvement on WER. However, compared with the previous two examples on convolutional neural network, DeepIoT fails to compress the model to less than 5% of the original parameters in the recurrent neural network case (still a 20-fold reduction though). e main reason is that compressing recurrent networks needs to prune both the output dimension and the hidden dimension. It has been shown that dropping hidden dimension can harm the network performance [57]. However DeepIoT is still successful in compressing network to less than 10% of parameters.
Fig. 4a shows the tradeo between word error rate and memory consumption by compressed models. DeepIoT achieves around ×7 be er tradeo compared with magnitude-based method, DyNS-Ext.
is means compressing recurrent neural networks requires more information about parameter redundancies within and among each layer. Compression using only local information, such as magnitude information, will cause degradation in the nal performance.

Fig. 4b shows the tradeo between word error rate and execution time. DeepIoT reduces execution time by 86.4% without degradation on WER compared with the original network. With the evaluation on Intel Edision, the original network requires 71.15 seconds in average to recognize one human speak voice example with the average length of 7.43 seconds. e compressed structure generated by DeepIoT reduces the average execution time to 9.68 seconds without performance loss, which improves responsiveness of human voice recognition.
Fig. 4c shows the tradeo between word error rate and energy consumption. DeepIoT reduces energy by 87% compared with the original network. It performs be er than DyNS-Ext by a large margin.
5.3 Supporting Human-Centric Context
Sensing
In addition to experiments about supporting basic human-centric interaction modalities, we evaluate DeepIoT on several humancentric context sensing applications. We compress the state-ofthe-art deep learning model, DeepSense, [56] for these problems and evaluate the accuracy and other system performance for the compressed networks. DeepSense contains all commonly used modules, including convolutional, recurrent, and fully-connected layers, which is also a good example to test the performance of compression algorithms on the combination of di erent types of neural network modules.
Two human-centric context sensing tasks we consider are heterogeneous human activity recognition (HHAR) and user identi cation with biometric motion analysis (UserID). e HHAR task recognizes human activities with motion sensors, accelerometer and gyroscope. “Heterogeneous” means that the task is focus on the generalization ability with human who has not appeared in the training set. e UserID task identi es users during a person’s daily activities such as walking, running, siting, and standing.

Compressing Deep Neural Network Structures for Sensing Systems

SenSys’17, November 6–8, 2017, Del , The Netherlands

Layer
conv1a conv1b (2 × 9) conv2a conv2b (1 × 3) conv3a conv3b (1 × 3)
conv4 (2 × 8) conv5 (1 × 6) conv6 (1 × 4)
gru1 gru2 fc1 total
Test Accuracy

Table 5: Heterogeneous human activity recognition

Hidden Unit

Params

DeepIoT (Hidden Units/ Params) DyNS-Ext

64

64

64

64

64

64

64

64

64

120

120

6

1.1K 1.1K 12.3K 12.3K 12.3K 12.3K
65.5K 24.6K 16.4K 227.5K 86.4K 0.7K 472.5K

20 19 20 14 23 23
10 12 17 27 31 6

31.25% 29.69%

9.76%

6.49%

11.23% 7.86%

5.61%

2.93%

4.98%

5.8%

6.24%

25.83%

6.16%

92% 95.7% 70.1% 77.7% 69.9% 66.2%
40.3% 27.2% 24.6% 1.2% 3.6% 98.6% 17.1%

94.6%

94.7%

94.6%

DyNS
50.3% 60.0% 25.3% 40.5% 32.1% 35.4%
20.4% 18.3% 12.0% 100% 100% 99% 74.5%
94.6%

SparseSep
100% 100% 114% 114% 114% 114%
53.7% 100% 100% 100% 100% 70% 95.3%
93.7%

Layer
conv1a conv1b (2 × 9) conv2a conv2b (1 × 3) conv3a conv3b (1 × 3)
conv4 (2 × 8) conv5 (1 × 6) conv6 (1 × 4)
gru1 gru2 fc1 total
Test Accuracy

Table 6: User identi cation with biometric motion analysis

Hidden Unit

Params

DeepIoT (Hidden Units/ Params) DyNS-Ext

64

64

64

64

64

64

64

64

64

120

120

9

1.1K 1.1K 12.3K 12.3K 12.3K 12.3K
65.5K 24.6K 16.4K 227.5K 86.4K 1.1K
472.9K

71 74 99
7 5 7 13 9 9

10.93% 1.56%

1.2%

0.1%

1.54% 0.88%

1.54%

0.85%

0.85%

1.18%

0.69%

7.5%

1.13%

64.4% 75.5% 32.5% 34.7% 31.6% 28.6%
12.1% 21.0% 18.9% 0.42% 1.61% 89.6%
7.76%

99.6%

99.6%

99.6%

DyNS
66.8% 65.6% 36.6% 48.0% 38.4% 43.5%
29.2% 23.3% 16.0% 100% 100% 98% 77.0%
99.6%

SparseSep
100% 100% 114% 114% 114% 114%
53.7% 100% 100% 100% 100% 88% 95.4%
98.8%

100

100

100

90

90

90

Accuracy (%)

80

95

70

90

85

60

80

75

70

50

65

600

0.02

0.04

0.06

0.08

DeepIoT DyNS−Ext DyNS SparseSep

40 0

0.2

0.4

0.6

0.8

1

Proportion of memory consumption by the model

Accuracy (%)

80

70

60

DeepIoT

50

DyNS−Ext

DyNS

SparseSep 40 20 40 60 80 100 120 140 160
Execution Time (ms)

Accuracy (%)

80

70

60

DeepIoT

50

DyNS−Ext

DyNS

SparseSep

400

20

40

60

80 100 120

Inference Energy (mJ)

(a) e tradeo between testing accuracy and(b) e tradeo between testing accuracy and (c) e tradeo between testing accuracy and

memory consumption by models.

execution time.

energy consumption.

Figure 5: System performance tradeo for heterogeneous human activity recognition

100

100

100

80

80

80

Accuracy (%)

Accuracy (%)

Accuracy (%)

100

60

60

60

90

80

40

DeepIoT

40

DeepIoT

40

DeepIoT

70

DyNS−Ext

DyNS−Ext

DyNS−Ext

DyNS

DyNS

DyNS

600

0.01 0.02 0.03 0.04 0.05 0.06

SparseSep

SparseSep

SparseSep

200

0.2

0.4

0.6

0.8

1

20 20 40 60 80 100 120 140 160

200

50

100

150

Proportion of memory consumption by the model

Execution Time (ms)

Inference Energy (mJ)

(a) e tradeo between testing accuracy and(b) e tradeo between testing accuracy and (c) e tradeo between testing accuracy and

memory consumption by models.

execution time.

energy consumption.

Figure 6: System performance tradeo for user identi cation with biometric motion analysis

In this evaluation section, we use the dataset collected by Al- users, 6 activities (biking, si ing, standing, walking, climbStairup,

lan et al. [45]. is dataset contains readings from two motion and climbStair-down), and 6 types of mobile devices. For both tasks,

sensors (accelerometer and gyroscope). Readings were recorded accelerometer and gyroscope measurements are model inputs. How-

when users execute activities scripted in no speci c order, while ever, for HHAR tasks, activities are used as labels, and for UserID

carrying smartwatches and smartphones. e dataset contains 9 tasks, users’ unique IDs are used as labels.

SenSys’17, November 6–8, 2017, Del , The Netherlands

Yao et al.

e original network structure of DeepSense is shown in the rst two columns of Table 5 and 6. Both tasks use a uni ed neural network structure as introduced in [56]. e structure contains both convolutional and recurrent layers. Since SparseSep and DyNS are not directly applicable to recurrent layers, we keep the recurrent layers unchanged while using them. In addition, we also compare DeepIoT with DyNS-Ext in this experiment.
Table 5 and 6 illustrate the statistics of nal pruned network generated by four algorithms that have no or acceptable degradation on testing accuracy. DeepIoT is the best-performing algorithm considering the remaining number of network parameters. is is mainly due to the design of compressor network and compressor-critic framework that jointly reduce the redundancies among parameters while maintaining a global view across di erent layers. DyNS and SparseSep are two algorithms that can be only applied to the fully-connected and convolutional layers in the original structure.
erefore there exists a lower bound of the le proportion of parameters, i.e., the number of parameters in recurrent layers. is lower bound is around 66%.
e detailed tradeo s between testing accuracy and memory consumption by the models are illustrated in Fig. 5a and 6a. DeepIoT still achieves the best tradeo for sensing applications. Other than the compressor neural network providing global parameter redundancies, directly pruning hidden elements in each layer also enables DeepIoT to obtain more concise representations in matrix form, which results in less memory consumption.
e tradeo s between system execution time and testing accuracy are shown in Fig. 5b and 6b. DeepIoT uses the least execution time when achieving the same testing accuracy compared with three baselines. It takes 36.7ms and 25.1ms for a single prediction, which reduces execution time by around 80.8% and 71.4% in UserID and HHAR, respectively, without loss of accuracy. DyNS and DyNSExt achieve be er performance on time compared with SparseSep, which is di erent from the previous evaluations on LeNet-5. It is the structure of the original neural network that causes this di erence. As shown in Table 5 and 6, the original network uses 1-d lters in its structure. e matrix factorization based kernel compressing method used in SparseSep cannot help to reduce or even increase the parameter redundancies and the number of operations involved.
erefore, there are constraints on the network structure when applying matrix factorization based compression algorithm. In addition, SparseSep cannot be applied to the recurrent layers in the network, which consumes a large proportion of operations during running the neural network.
e tradeo s between energy consumption and testing accuracy are shown in Fig. 5c and 6c. DeepIoT is the best-performing algorithm for energy consumption. It reduces energy by around 83.3% and 72.2% in UserID and HHAR without loss of accuracy. Due to the aforementioned problem of SparseSep on 1-d lter, redundant factorization causes more execution time and energy consumption in the experiment.
6 DISCUSSION
is paper tries to apply state-of-the-art neural network models on resource-constrained embedded and mobile devices by simplifying network structure without hurting accuracy. Our solution, DeepIoT,

generates a simpli ed network structure by deciding which elements to drop in each layer. is whole process requires ne-tuning (Line 18 to Line 21 in Algorithm 1). However, we argue that the
ne-tuning step should not be the obstacle in applying DeepIoT. First, all the compressing and ne-tuning steps are conducted on the workstation instead of embedded and mobile devices. We can easily apply the DeepIoT algorithm to compress and ne-tune the neural network ahead of time and then deploy the compressed model into embedded and mobile devices without any run-time processing. Second, the original training data must be easily accessible. Developers who want to apply neural networks to solve their own sensing problems will typically have access to their own datasets to ne-tune the model. For others, lots of large-scale datasets are available online, such as vision [11] and audio [16] data. Hence, for many categories of applications, ne-tuning is feasible.
DeepIoT mainly focuses on structure pruning or weight pruning, which is independent from other model compression methods such as weight quantization [9, 10, 18, 23]. Although weight quantization can compress the network complexity by using limited numerical precision or clustering parameters, the compression ratio of quantization is usually less than the structure pruning methods. Weight pruning and quantization are two non-con icting methods. We can apply weight quantization a er the structure pruning step or a er any other compression algorithm. is is out of the scope of this paper. Also we do not exploit heterogeneous local device processors, such as DSPs [30], to speed up the running time during all the experiments, because this paper focuses on structure compression methods for deep neural networks instead of hardware speed-up.
7 CONCLUSION
In this paper, we described DeepIoT, a compression algorithm that learns a more succinct network structure for sensing applications. DeepIoT integrates the original network with dropout learning and generates stochastic hidden elements in each layer. We also described a novel compressor neural network to learn the parameter redundancies and generate dropout probabilities for original network layers. e compressor neural network is optimized jointly with the original neural network through the compressor-critic framework. DeepIoT outperforms other baseline compression algorithms by a signi cant margin in all experiments. e compressed structure greatly reduces the resource consumption on sensing system without hurting the performance, and makes a lot of the stateof-the-art deep neural networks deployable on resource-constrained embedded and mobile devices.
ACKNOWLEDGMENTS
We sincerely thank Nicholas D. Lane for shepherding the nal version of this paper, and the anonymous reviewers for their invaluable comments. Research reported in this paper was sponsored in part by NSF under grants CNS 16-18627 and CNS 13-20209 and in part by the Army Research Laboratory under Cooperative Agreement W911NF-09-2-0053. e views and conclusions contained in this document are those of the authors and should not be interpreted as representing the o cial policies, either expressed or implied, of the Army Research Laboratory, NSF, or the U.S. Government. e U.S. Government is authorized to reproduce and distribute reprints

Compressing Deep Neural Network Structures for Sensing Systems

SenSys’17, November 6–8, 2017, Del , The Netherlands

for Government purposes notwithstanding any copyright notation
here on.
REFERENCES
[1] [n. d.]. Intel Edison Compute Module. h p://www.intel.com/content/dam/ support/us/en/documents/edison/sb/edison-module HG 331189.pdf. ([n. d.]).
[2] [n. d.]. Loading Debian (Ubilinux) on the Edison. h ps://learn.sparkfun.com/ tutorials/loading-debian-ubilinux-on-the-edison. ([n. d.]).
[3] Mohammad Abu Alsheikh, Shaowei Lin, Dusit Niyato, and Hwee-Pink Tan. 2014. Machine learning in wireless sensor networks: Algorithms, strategies, and applications. IEEE Communications Surveys & Tutorials 16, 4 (2014), 1996–2018.
[4] Sourav Bha acharya and Nicholas D Lane. 2016. Sparsi cation and separation of deep learning layers for constrained resource inference on wearables. In
Proceedings of the 14th ACM Conference on Embedded Network Sensor Systems CD-ROM. ACM, 176–189. [5] Niels Brouwers, Marco Zuniga, and Koen Langendoen. 2014. Incremental wiscanning for energy-e cient localization. In Pervasive Computing and Communications (PerCom), 2014 IEEE International Conference on. IEEE, 156–162. [6] Licia Capra, Wolfgang Emmerich, and Cecilia Mascolo. 2003. Carisma: Contextaware re ective middleware system for mobile applications. IEEE Transactions on so ware engineering 29, 10 (2003), 929–945. [7] Eunjoon Cho, Kevin Wong, Omprakash Gnawali, Martin Wicke, and Leonidas Guibas. 2011. Inferring mobile trajectories using a network of binary proximity sensors. In Sensor, Mesh and Ad Hoc Communications and Networks (SECON), 2011 8th Annual IEEE Communications Society Conference on. IEEE, 188–196. [8] Ronald Clark, Sen Wang, Hongkai Wen, Andrew Markham, and Niki Trigoni. 2017. VINet: Visual Inertial Odometry as a Sequence to Sequence Learning Problem. In AAAI Conference on Arti cial Intelligence (AAAI). [9] Ma hieu Courbariaux, Yoshua Bengio, and Jean-Pierre David. 2014. Training deep neural networks with low precision multiplications. arXiv preprint arXiv:1412.7024 (2014). [10] Ma hieu Courbariaux, Itay Hubara, Daniel Soudry, Ran El-Yaniv, and Yoshua Bengio. 2016. Binarized neural networks: Training deep neural networks with weights and activations constrained to+ 1 or-1. arXiv preprint arXiv:1602.02830 (2016). [11] Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. 2009. Imagenet: A large-scale hierarchical image database. In Computer Vision and Pa ern Recognition, 2009. CVPR 2009. IEEE Conference on. IEEE, 248–255. [12] Emily L Denton, Wojciech Zaremba, Joan Bruna, Yann LeCun, and Rob Fergus. 2014. Exploiting linear structure within convolutional networks for e cient evaluation. In Advances in Neural Information Processing Systems. 1269–1277. [13] Federico Ferrari, Marco Zimmerling, Luca Mo ola, and Lothar iele. 2012. Lowpower wireless bus. In Proceedings of the 10th ACM Conference on Embedded Network Sensor Systems. ACM, 1–14. [14] Yarin Gal and Zoubin Ghahramani. 2015. Bayesian convolutional neural networks with Bernoulli approximate variational inference. arXiv preprint arXiv:1506.02158 (2015). [15] Yarin Gal and Zoubin Ghahramani. 2016. A eoretically Grounded Application of Dropout in Recurrent Neural Networks. (2016). [16] Jort F. Gemmeke, Daniel P. W. Ellis, Dylan Freedman, Aren Jansen, Wade Lawrence, R. Channing Moore, Manoj Plakal, and Marvin Ri er. 2017. Audio Set: An ontology and human-labeled dataset for audio events. In Proc. IEEE ICASSP 2017. New Orleans, LA. [17] Peter W Glynn. 1990. Likelihood ratio gradient estimation for stochastic systems. Commun. ACM 33, 10 (1990), 75–84. [18] Yunchao Gong, Liu Liu, Ming Yang, and Lubomir Bourdev. 2014. Compressing deep convolutional networks using vector quantization. arXiv preprint arXiv:1412.6115 (2014). [19] Georgios Goumas, Kornilios Kourtis, Nikos Anastopoulos, Vasileios Karakasis, and Nectarios Koziris. 2008. Understanding the performance of sparse matrixvector multiplication. In Parallel, Distributed and Network-Based Processing, 2008. PDP 2008. 16th Euromicro Conference on. IEEE, 283–292. [20] Alex Graves and Navdeep Jaitly. 2014. Towards End-To-End Speech Recognition with Recurrent Neural Networks.. In ICML, Vol. 14. 1764–1772. [21] Shixiang Gu, Sergey Levine, Ilya Sutskever, and Andriy Mnih. 2015. MuProp: Unbiased Backpropagation for Stochastic Neural Networks. arXiv preprint arXiv:1511.05176 (2015). [22] Yiwen Guo, Anbang Yao, and Yurong Chen. 2016. Dynamic Network Surgery for E cient DNNs. In Advances In Neural Information Processing Systems. 1379–1387. [23] Suyog Gupta, Ankur Agrawal, Kailash Gopalakrishnan, and Pritish Narayanan. 2015. Deep Learning with Limited Numerical Precision.. In ICML. 1737–1746. [24] Song Han, Huizi Mao, and William J Dally. 2015. Deep compression: Compressing deep neural network with pruning, trained quantization and hu man coding. CoRR, abs/1510.00149 2 (2015). [25] Josiah Hester, Travis Peters, Tianlong Yun, Ronald Peterson, Joseph Skinner, Bhargav Golla, Kevin Storer, Steven Hearndon, Kevin Freeman, Sarah Lord, et al.

2016. Amulet: An Energy-E cient, Multi-Application Wearable Platform. In
Proceedings of the 14th ACM Conference on Embedded Network Sensor Systems CD-ROM. ACM, 216–229. [26] Geo rey Hinton, Oriol Vinyals, and Je Dean. 2015. Distilling the knowledge in a neural network. arXiv preprint arXiv:1503.02531 (2015). [27] Enamul Hoque, Robert F Dickerson, and John A Stankovic. 2014. Vocal-diary: A voice command based ground truth collection system for activity recognition. In Proceedings of the Wireless Health 2014 on National Institutes of Health. ACM, 1–6. [28] Vijay R Konda and John N Tsitsiklis. 1999. Actor-Critic Algorithms.. In NIPS, Vol. 13. 1008–1014. [29] Branislav Kusy, Akos Ledeczi, and Xenofon Koutsoukos. 2007. Tracking mobile nodes using rf doppler shi s. In Proceedings of the 5th international conference on Embedded networked sensor systems. ACM, 29–42. [30] Nicholas D Lane, Sourav Bha acharya, Petko Georgiev, Claudio Forlivesi, Lei Jiao, Lorena Qendro, and Fahim Kawsar. 2016. Deepx: A so ware accelerator for low-power deep learning inference on mobile devices. In Information Processing in Sensor Networks (IPSN), 2016 15th ACM/IEEE International Conference on. IEEE, 1–12. [31] Nicholas D Lane, Petko Georgiev, and Lorena Qendro. 2015. DeepEar: robust smartphone audio sensing in unconstrained acoustic environments using deep learning. In Proceedings of the 2015 ACM International Joint Conference on Pervasive and Ubiquitous Computing. ACM, 283–294. [32] Andriy Mnih and Karol Gregor. 2014. Neural variational inference and learning in belief networks. (2014). [33] Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A. Rusu, Joel Veness, Marc G. Bellemare, Alex Graves, Martin A. Riedmiller, Andreas Fidjeland, Georg Ostrovski, Stig Petersen, Charles Bea ie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran, Daan Wierstra, Shane Legg, and Demis Hassabis. 2015. Human-level control through deep reinforcement learning. Nature 518 (2015), 529–533. [34] Shahriar Nirjon, Robert F Dickerson, Qiang Li, Philip Asare, John A Stankovic, Dezhi Hong, Ben Zhang, Xiaofan Jiang, Guobin Shen, and Feng Zhao. 2012. Musicalheart: A hearty way of listening to music. In Proceedings of the 10th ACM Conference on Embedded Network Sensor Systems. ACM, 43–56. [35] Vassil Panayotov, Guoguo Chen, Daniel Povey, and Sanjeev Khudanpur. 2015. Librispeech: an ASR corpus based on public domain audio books. In Acoustics, Speech and Signal Processing (ICASSP), 2015 IEEE International Conference on. IEEE, 5206–5210. [36] Jan Peters and Stefan Schaal. 2006. Policy gradient methods for robotics. In 2006 IEEE/RSJ International Conference on Intelligent Robots and Systems. IEEE, 2219–2225. [37] Valentin Radu, Nicholas D Lane, Sourav Bha acharya, Cecilia Mascolo, Mahesh K Marina, and Fahim Kawsar. 2016. Towards multimodal deep learning for activity recognition on mobile devices. In Proceedings of the 2016 ACM International Joint Conference on Pervasive and Ubiquitous Computing: Adjunct. ACM, 185–188. [38] Stefano Rosa, Xiaoxuan Lu, Hongkai Wen, and Niki Trigoni. 2017. Leveraging User Activities and Mobile Robots for Semantic Mapping and User Localization. In Proceedings of the Companion of the 2017 ACM/IEEE International Conference on Human-Robot Interaction. ACM, 267–268. [39] Anthony Rowe, Mario Berges, and Raj Rajkumar. 2010. Contactless sensing of appliance state transitions through variations in electromagnetic elds. In
Proceedings of the 2nd ACM workshop on embedded sensing systems for energye ciency in building. ACM, 19–24. [40] Abusayeed Saifullah, Mahbubur Rahman, Dali Ismail, Chenyang Lu, Ranveer Chandra, and Jie Liu. 2016. SNOW: Sensor network over white spaces. In Pro-
ceedings of the International Conference on Embedded Networked Sensor Systems (ACM SenSys). [41] Markus Schuss, Carlo Alberto Boano, Manuel Weber, and Kay Roemer. 2017. A Competition to Push the Dependability of Low-Power Wireless Protocols to the Edge. In Proceedings of the 14th International Conference on Embedded Wireless Systems and Networks (EWSN). Uppsala, Sweden. [42] Yiran Shen, Wen Hu, Mingrui Yang, Bo Wei, Simon Lucey, and Chun Tung Chou. 2014. Face recognition on smartphones via optimised sparse representation classi cation. In Information Processing in Sensor Networks, IPSN-14 Proceedings of the 13th International Symposium on. IEEE, 237–248. [43] David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schri wieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. 2016. Mastering the game of Go with deep neural networks and tree search. Nature 529, 7587 (2016), 484–489. [44] Nitish Srivastava, Geo rey E Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. 2014. Dropout: a simple way to prevent neural networks from over ing. Journal of Machine Learning Research 15, 1 (2014), 1929–1958. [45] Allan Stisen, Henrik Blunck, Sourav Bha acharya, or Siiger Prentow, Mikkel Baun Kjærgaard, Anind Dey, Tobias Sonne, and Mads Møller Jensen. 2015. Smart devices are di erent: Assessing and mitigatingmobile sensing heterogeneities for activity recognition. In Proceedings of the 13th ACM Conference on Embedded Networked Sensor Systems. ACM, 127–140.

SenSys’17, November 6–8, 2017, Del , The Netherlands

Yao et al.

[46] Zheng Sun, Aveek Purohit, Kaifei Chen, Shijia Pan, Trevor Pering, and Pei Zhang. 2011. PANDAA: physical arrangement detection of networked devices through ambient-sound awareness. In Proceedings of the 13th international conference on Ubiquitous computing. ACM, 425–434.
[47] Cheng Tai, Tong Xiao, Yi Zhang, Xiaogang Wang, et al. 2015. Convolutional neural networks with low-rank regularization. arXiv preprint arXiv:1511.06067 (2015).
[48] eano Development Team. 2016. eano: A Python framework for fast computation of mathematical expressions. arXiv e-prints abs/1605.02688 (May 2016). h p://arxiv.org/abs/1605.02688
[49] Shuai Wang, Song Min Kim, Yunhuai Liu, Guang Tan, and Tian He. 2013. Corlayer: A transparent link correlation layer for energy e cient broadcast. In Proceedings of the 19th annual international conference on Mobile computing & networking. ACM, 51–62.
[50] Shangxing Wang, Hanpeng Liu, Pedro Henrique Gomes, and Bhaskar Krishnamachari. 2017. Deep Reinforcement Learning for Dynamic Multichannel Access. (2017).
[51] Yunhe Wang, Chang Xu, Shan You, Dacheng Tao, and Chao Xu. 2016. CNNpack: packing convolutional neural networks in the frequency domain. In Advances in Neural Information Processing Systems. 253–261.
[52] Hongkai Wen, Shangxing Wang, Ronald Clark, and Niki Trigoni. 2017. DeepVO: Towards End-to-End Visual Odometry with Deep Recurrent Convolutional Neural Networks. International Conference on Robotics and Automation (2017).
[53] Joey Wilson and Neal Patwari. 2011. See-through walls: Motion tracking using variance-based radio tomography networks. IEEE Transactions on Mobile Computing 10, 5 (2011), 612–621.

[54] Jie Yang, Simon Sidhom, Gayathri Chandrasekaran, Tam Vu, Hongbo Liu, Nicolae Cecan, Yingying Chen, Marco Gruteser, and Richard P Martin. 2011. Detecting driver phone use leveraging car speakers. In Proceedings of the 17th annual international conference on Mobile computing and networking. ACM, 97–108.
[55] Shuochao Yao, Md Tanvir Amin, Lu Su, Shaohan Hu, Shen Li, Shiguang Wang, Yiran Zhao, Tarek Abdelzaher, Lance Kaplan, Charu Aggarwal, et al. 2016. Recursive ground truth estimator for social data streams. In Information Processing in Sensor Networks (IPSN), 2016 15th ACM/IEEE International Conference on. IEEE, 1–12.
[56] Shuochao Yao, Shaohan Hu, Yiran Zhao, Aston Zhang, and Tarek Abdelzaher. 2017. DeepSense: a Uni ed Deep Learning Framework for Time-Series Mobile Sensing Data Processing. In Proceedings of the 26th International Conference on World Wide Web. International World Wide Web Conferences Steering Committee.
[57] Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals. 2014. Recurrent neural network regularization. arXiv preprint arXiv:1409.2329 (2014).
[58] Chao Zhang, Keyang Zhang, an Yuan, Haoruo Peng, Yu Zheng, Tim Hanra y, Shaowen Wang, and Jiawei Han. 2017. Regions, periods, activities: Uncovering urban dynamics via cross-modal representation learning. In Proceedings of the 26th International Conference on World Wide Web. International World Wide Web Conferences Steering Commi ee, 361–370.
[59] Mi Zhang, Anand Joshi, Ritesh Kadmawala, Karthik Dantu, Sameera Poduri, and Gaurav S Sukhatme. 2009. Ocrdroid: A framework to digitize text using mobile phones. In International Conference on Mobile Computing, Applications, and Services. Springer, 273–292.

