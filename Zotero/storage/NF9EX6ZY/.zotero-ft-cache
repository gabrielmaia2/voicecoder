Autoencoders
Dor Bank, Noam Koenigstein, Raja Giryes

arXiv:2003.05991v2 [cs.LG] 3 Apr 2021

Abstract An autoencoder is a speciï¬c type of a neural network, which is mainly designed to encode the input into a compressed and meaningful representation, and then decode it back such that the reconstructed input is similar as possible to the original one. This chapter surveys the diï¬€erent types of autoencoders that are mainly used today. It also describes various applications and use-cases of autoencoders.

1 Autoencoders

Autoencoders have been ï¬rst introduced in [43] as a neural network that is trained to reconstruct its input. Their main purpose is learning in an unsupervised manner an â€œinformativeâ€ representation of the data that can be used for various implications such as clustering. The problem, as formally deï¬ned in [2], is to learn the functions ğ´ : Rğ‘› â†’ Rğ‘ (encoder) and ğµ : Rğ‘ â†’ Rğ‘› (decoder) that satisfy

arg minğ´,ğµ ğ¸ [Î”(x, ğµ â—¦ ğ´(x)],

(1)

where ğ¸ is the expectation over the distribution of ğ‘¥, and Î” is the reconstruction loss function, which measures the distance between the output of the decoder and the intput. The latter is usually set to be the â„“2-norm. Figure 1 provides an illustration of the autoencoder model.

Dor Bank School of Electrical Engineering, Tel Aviv University, e-mail: dorbank@mail.tau.ac.il Noam Koenigstein Department of Industrial Engineering, Faculty of Engineering, Tel Aviv University, e-mail: noamk@ tauex.tau.ac.il Raja Giryes School of Electrical Engineering, Tel Aviv University, e-mail: raja@tauex.tau.ac.il
1

2

Dor Bank, Noam Koenigstein, Raja Giryes

Fig. 1: An autoencoder example. The input image is encoded to a compressed representation and then decoded.
In the most popular form of autoencoders, ğ´ and ğµ are neural networks [40]. In the special case that ğ´ and ğµ are linear operations, we get a linear autoencoder [3]. In the case of linear autoencoder where we also drop the non-linear operations, the autoencoder would achieve the same latent representation as Principal Component Analysis (PCA) [38]. Therefore, an autoencoder is in fact a generalization of PCA, where instead of ï¬nding a low dimensional hyperplane in which the data lies, it is able to learn a non-linear manifold.
Autoencoders may be trained end-to-end or gradually layer by layer. In the latter case, they are â€stackedâ€ together, which leads to a deeper encoder. In [35], this is done with convolutional autoencoders, and in [54] with denoising autoencoder (described below).
This chapter is organized as follows. In Section 2, diï¬€erent regularization techniques for autoencoders are considered, whose goal is to ensure that the learned compressed representation is meaningful. In Section 3, the variational autoencoders are presented, which are considered to be the most popular form of autoencoders. Section 4 covers very common applications for autoencoders, Section 5.1 brieï¬‚y discusses the comparison between autoencoders and generative adversarial networks, and Section 5 describes some recent advanced techniques in this ï¬eld. Section 6 concludes this chapter.
2 Regularized autoencoders
Since in training, one may just get the identity operator for ğ´ and ğµ, which keeps the achieved representation the same as the input, some additional regularization is required. The most common option is to make the dimension of the representation smaller than the input. This way, a ğ‘ğ‘œğ‘¡ğ‘¡ğ‘™ğ‘’ğ‘›ğ‘’ğ‘ğ‘˜ is imposed. This option also directly serves the goal of getting a low dimensional representation of the data. This representation can be used for purposes such as data compression, feature extraction, etc. Its important to note that even if the ğ‘ğ‘œğ‘¡ğ‘¡ğ‘™ğ‘’ğ‘›ğ‘’ğ‘ğ‘˜ is comprised of only one node, then

Autoencoders

3

overï¬tting is still possible if the capacity of the encoder and the decoder is large enough to encode each sample to an index.
In cases where the size of the hidden layer is equal or greater than the size of the input, there is a risk that the encoder will simply learn the identity function. To prevent it without creating a bottleneck (i.e. smaller hidden layer) several options exists for regularization, which we describe hereafter, that would enforce the autoencoder to learn a diï¬€erent representation of the input.
An important tradeoï¬€ in autoencoders is the bias-variance tradeoï¬€. On the one hand, we want the architecure of the autoencoder to be able to reconstruct the input well (i.e. reduce the reconstruction error). On the other hand, we want the low representation to generalize to a meaningful one. We now turn to describe diï¬€erent methods to tackle such tradeoï¬€s.

2.1 Sparse Autoencoders

One way to deal with this tradeoï¬€ is to enforce sparsity on the hidden activations. This can be added on top of the bottleneck enforcement, or instead of it. There are two strategies to enforce the sparsity regularization. They are similar to ordinary regularization, where they are applied on the activations instead of the weights. The ï¬rst way to do so, is to apply ğ¿1 regularization, which is known to induce sparsity. Thus, the autoencoder optimization objective becomes:

âˆ‘ï¸

arg minğ´,ğµ ğ¸ [Î”(x, ğµ â—¦ ğ´(x)] + ğœ† |ğ‘ğ‘– |,

(2)

ğ‘–

where ğ‘ğ‘– is the activation at the ğ‘–th hidden layer and ğ‘– iterates over all the hiddens

activations. Another way to do so, is to use the KL-divergence, which is a measure of

the distance between two probability distributions. Instead of tweaking the ğ‘™ğ‘ğ‘šğ‘ğ‘‘ğ‘

parameter as in the ğ¿1 regularization, we can assume the activation of each neuron acts as a Bernouli variable with probability ğ‘ and tweak that probability. At each

batch, the actual probability is then measured, and the diï¬€erence is calculated and

applied as a regularization factor. For each neuron ğ‘—, the calculated empirical prob-

ability

is

ğ‘Ë† ğ‘—

=

1 ğ‘š

ğ‘– ğ‘ğ‘– (ğ‘¥), where ğ‘– iterates over the samples in the batch. Thus the

overall loss function would be

âˆ‘ï¸

arg minğ´,ğµ ğ¸ [Î”(x, ğµ â—¦ ğ´(x)] + ğ¾ ğ¿ ( ğ‘|| ğ‘Ë† ğ‘— ),

(3)

ğ‘—

where the regularization term in it aims at matching ğ‘ to ğ‘Ë†.

4
2.2 Denoising Autoencoders

Dor Bank, Noam Koenigstein, Raja Giryes

Denoising autoencoders [53] can be viewed either as a regularization option, or as robust autoencoders which can be used for error correction. In these architectures, the input is disrupted by some noise (e.g., additive white Gaussian noise or erasures using Dropout) and the autoencoder is expected to reconstruct the clean version of the input, as illustrated in Figure 2.

Fig. 2: A denoising autoencoder example. The disrupted input image is encoded to a representation and then decoded.

Note that xËœ is a random variable, whose distribution is given by ğ¶ (xËœ |x). Two common options for ğ¶ are:

ğ¶ğœ (xËœ |x) = N (x, ğœ2I),

(4)

and

ğ¶ğ‘ (xËœ |x) = ğ›½ x, ğ›½ âˆ¼ ğµğ‘’ğ‘Ÿ ( ğ‘),

(5)

where detnotes an element-wise (Hadamard) product. In the ï¬rst option, the variance parameter ğœ sets the impact of the noise. In the second, the parameter ğ‘ sets the probability of a value in x not being nulliï¬ed. A relationship between denoising autoencoders with dropout to analog coding with erasures has been shown in [4].

Autoencoders

5

2.3 Contractive Autoencoders

In denoising autoencoders, the emphasis is on letting the encoder be resistant to some perturbations of the input. In contractive autoencoders, the emphasis is on making the feature extraction less sensitive to small perturbations, by forcing the encoder to disregard changes in the input that are not important for the reconstruction by the decoder. Thus, a penatly is imposed on the Jacobian of the network. The Jacobian matrix of the hidden layer â„ consists of the derivative of each node â„ ğ‘— with respect to each value ğ‘¥ğ‘– in the input ğ‘¥. Formally: ğ½ ğ‘—ğ‘– = âˆ‡ğ‘¥ğ‘– â„ ğ‘— (ğ‘¥ğ‘–). In contractive autoencoders we try to minimize its L2 norm, such that the overall optimization loss would be:

arg minğ´,ğµ ğ¸ [Î”(ğ‘¥, ğµ â—¦ ğ´(ğ‘¥)] + ğœ†||ğ½ğ´(ğ‘¥)||22.

(6)

The reconstruction loss function and the regularization loss actually pull the result towards opposite directions. By minimizing the squared Jacobian norm, all the latent representations of the input tend to be more similar to each other, and by thus make the reconstruction more diï¬ƒcult, since the diï¬€erences between the representations are smaller. The main idea is that variations in the latent representation that are not important for the reconstructions would be diminished by the regularization factor, while important variations would remain because of their impact on the reconstruction error.

3 Variational Autoencoders

A major improvement in the representation capabilities of autoencoders has been

achieved by the Variational Autoencoders (VAE) model [27]. Following Variational

Bayes (VB) Inference [6], VAE are generative models that attempt to describe

data generation through a probabilistic distribution. Speciï¬cally, given an observed

dataset X = {xğ‘– }ğ‘–ğ‘=1 of ğ‘‰ i.i.d samples, we assume a generative model for each datum xğ‘– conditioned on an unobserved random latent variable zğ‘–, where ğœƒ are the param-

eters governing the generative distribution. This generative model is also equivalent

to a probabilistic decoder. Symmetrically, we assume an approximate posterior dis-

tribution over the latent variable zğ‘– given a datum xğ‘– denoted by recognition, which

is equivalent a probabilistic encoder and governed by the parameters ğœ™. Finally, we

assume a prior distribution for the latent variables zğ‘– denoted by ğ‘ ğœƒ (zğ‘–). Figure 3

depicts the relationship described above. The parameters ğœƒ and ğœ™ are unknown and

needs to learned from the data. The observed latent variables zğ‘– can be interpreted

as a code given by the recognition model ğ‘ ğœ™ (z|x).

The marginal log-likelihood is expressed as a sum over the individual data points

log ğ‘ ğœƒ (x1, x2, ..., xğ‘ ) =

ğ‘ ğ‘–=1

log

ğ‘

ğœƒ

(xğ‘–

),

and

each

point

can

be

rewritten

as:

log ğ‘ ğœƒ (xğ‘–) = ğ·ğ¾ ğ¿ ğ‘ ğœ™ (z|xğ‘–) || ğ‘ ğœƒ (z|xğ‘–) + L (ğœƒ, ğœ™; xğ‘–),

(7)

6

Dor Bank, Noam Koenigstein, Raja Giryes

Fig. 3: A Graphical Representatin of VAE

where the ï¬rst term is the Kullback-Leibler divergence of the approximate recognition model from the true posterior and the second term is called the variational lower bound on the marginal likelihood deï¬ned as:

L (ğœƒ, ğœ™; xğ‘–) Eğ‘ğœ™ (z|xğ‘–) âˆ’ log ğ‘ ğœ™ (z|x) + log ğ‘ ğœƒ (x, z) .

(8)

Since the Kullback-Leibler divergence is non-negative, L (ğœƒ, ğœ™; xğ‘–) is a lower bound on the marginal log-likelihood and the marginal log-likelihood is independent of the parameters ğœƒ and ğœ™, maximizing the lower bound improves our approximation of the posterior with respect to the Kullback-Leibler divergence.
The variational lower bound can be further expanded as follows:

L (ğœƒ, ğœ™; xğ‘–) = âˆ’ğ·ğ¾ ğ¿ ğ‘ ğœ™ (z|xğ‘–)|| ğ‘ ğœƒ (z) + Eğ‘ğœ™ (z|xğ‘–) log ğ‘ ğœƒ (xğ‘– |z)

(9)

Variational inference follows by maximizing L (ğœƒ, ğœ™; xğ‘–) for all data points with
respect to ğœƒ and ğœ™. Given a dataset X = {xğ‘– }ğ‘–ğ‘=1 with ğ‘ data points, we can estimate the marginal
likelihood lower-bound of the full dataset L (ğœƒ, ğœ™; X) using a mini-batch Xğ‘€ = {xğ‘– }ğ‘–ğ‘€=1 of size ğ‘€ as follows:

ğ‘€

L (ğœƒ, ğœ™; X) â‰ˆ LËœ ğ‘€ (ğœƒ, ğœ™; Xğ‘€ ) =

ğ‘

âˆ‘ï¸ L (ğœƒ, ğœ™; xğ‘–)

(10)

ğ‘€

ğ‘–=1

Classical mean-ï¬eld VB assumes a factorized approximate posterior followed by a closed form optimization updates (which usually required conjugate priors). However, VAE follows a diï¬€erent path in which the gradients of LËœ ğ‘€ (ğœƒ, ğœ™; Xğ‘€ ) are approximated using a the reparameterization trick and stochastic gradient optimization.

Autoencoders

7

3.1 The Reparameterization Trick

The reparameterization trick is a simple approach to estimate L (ğœƒ, ğœ™; xğ‘–) based on a small sample of size ğ¿. Consider Equation 8, we can reparameterize the random variable zËœ âˆ¼ ğ‘ ğœ™ (z|x) using a diï¬€erentiable transformation ğ‘”ğœ™ (ğœ–, x) using an auxiliary noise vrabile ğœ– drawn from some distribution ğœ– âˆ¼ ğ‘(ğœ–) [27]. Using this tecnique, L (ğœƒ, ğœ™; xğ‘–) is approximated as follows:

L (ğœƒ, ğœ™; xğ‘–)

â‰ˆ LËœ (ğœƒ, ğœ™; xğ‘–)

=

1

ğ¿
âˆ‘ï¸ log ğ‘ ğœƒ (xğ‘–, z(ğ‘–,ğ‘™) ) âˆ’ log ğ‘ ğœ™ (z(ğ‘–,ğ‘™) |xğ‘– ),

(11)

ğ¿

ğ‘™=1

where z(ğ‘–,ğ‘™) = ğ‘”ğœ™ (ğœ–(ğ‘–,ğ‘™) , xğ‘–) and ğœ–(ğ‘–,ğ‘™) is a random noise drawn from ğœ–ğ‘™ âˆ¼ ğ‘(ğœ–). Remember we wish to optimize the mini-batch estimates from Equation 10. By
plugging Equation 11 we get the following diï¬€erentiable expression:

ğ‘€

LË† ğ‘€ (ğœƒ, ğœ™; X) = ğ‘ âˆ‘ï¸ LËœ (ğœƒ, ğœ™; xğ‘–),

(12)

ğ‘€

ğ‘–=1

which can be derived according to ğœƒ and ğœ™ and plugged into an optimizer framework.

Algorithm 1 Pseudo-code for VAE
( ğœƒ , ğœ™) â† Initialize Parameter repeat
Xğ‘€ â† Random minibatch of ğ‘€ datapoints ğœ– â† ğ¿ random samples of ğ‘ ( ğœ– ) g â† âˆ‡( ğœƒ,ğœ™) LË†M ( ğœƒ , ğœ™; X) {Gradients of Equation 12} ( ğœƒ , ğœ™) â† Update parameters based on g {e.g., update with SGD or Adagrad} until Convergenge of ( ğœƒ , ğœ™) return ( ğœƒ , ğœ™)

Algorithm 1 summarizes the full optimization procedure for VAE. Often ğ¿ can be set to 1 so long as ğ‘€ is large enough. Typical numbers are ğ‘€ = 100 and ğ¿ = 1.
Equation11 presents a lower bound on the log-likelihood log ğ‘ ğœƒ (xğ‘–). In [8], the equation is changed to

L (ğœƒ, ğœ™; xğ‘–)

=

1 ğ¿

ğ¿
âˆ‘ï¸ log
ğ‘™=1

1 ğ‘˜

ğ‘˜
âˆ‘ï¸
ğ‘— =1

ğ‘ ğœƒ (xğ‘–, z( ğ‘—,ğ‘™) ) .
ğ‘ ğœ™ (z( ğ‘—,ğ‘™) |xğ‘– )

(13)

Intuitively, instead of taking the gradient of a single randomized latent representation, the gradients of the generative network are learned by a weighted average of the sample over diï¬€erent samples from its (approximated) posterior distribution. The weights simply the likelihood functions ğ‘ ğœ™ (z( ğ‘—,ğ‘™) |xğ‘– ).

8

Dor Bank, Noam Koenigstein, Raja Giryes

3.2 Example: The Case of Normal Distribution

Usually, we approximate ğ‘(z|x) with a Gaussian distribution ğ‘ ğœ™ (z|x) = N (ğ‘”(x), â„(x)), where ğ‘”(x) and â„(x) are the mean and the covariance of the distribution deï¬ned by the encoder network. Namely, the encoder takes an input xğ‘– and maps it into a mean and covariance that determine the approximate posterior distribution ğ‘ ğœ™ (z|x).
To enable backpropagation through the network, sampling from ğ‘ ğœ™ (z|x) can simpliï¬ed using the reparametrisation trick as follows:

z = â„(x)ğœ‰ + ğ‘”(x),

(14)

where ğœ‰ âˆ¼ N (0, I) is a normal distribution. Finally, we denote the decoder with an additional function ğ‘“ , and require that
ğ‘¥ â‰ˆ ğ‘“ (z). The loss function of the entire network then becomes:

ğ‘™ğ‘œğ‘ ğ‘  = ğ‘ ğ‘¥ âˆ’ ğ‘“ (z) 2 + ğ·ğ¾ ğ¿ (N (ğ‘”(x), â„(x)), N (0, I)) ,

(15)

which can be automatically derived with respect to the network parameters in ğ‘”, â„ and ğ‘“ and optimized with backpropogation.

3.3 Disentangled Autoencoders
The variational lower bound as presented at Eq. 9, can be viewed as the summation of two terms: The right term that includes the reconstruction capability of samples, and the left term that acts as a regularization that biases ğ‘ ğœ™ (ğ‘§|x(ğ‘–) towards the assumed prior ğ‘ ğœƒ (ğ‘§). Disentangled autoencoders include variational autoencoders with a small addition. They add a parameter ğ›½ is as a multiplicative factor for the ğ¾ ğ¿ divergence [23] at Eq. 9. Its maximization factor is thus:
L (ğœƒ, ğœ™, x(ğ‘–) ) = âˆ’ğ›½ğ·ğ¾ ğ¿ (ğ‘ ğœ™ (ğ‘§|x(ğ‘–) ) || ğ‘ ğœƒ (ğ‘§)) + Eğ‘ğœ™ (ğ‘§ |x(ğ‘–) ) [log ğ‘ ğœƒ (x(ğ‘–) |ğ‘§)]. (16)
In practice, the prior ğ‘ ğœƒ (ğ‘§) is commonly set as the standard multivariate normal distribution N (0, I). In those cases, all the features are uncorrelated, and the ğ¾ ğ¿ divergence regularizes the latent features distribution ğ‘ ğœ™ (ğ‘§|x(ğ‘–) to a less correlated one. Note that the larger the ğ›½, the less correlated (more disentangled) the features will be.

4 Applications of autoencoders
Learning a representation via the autoencoder can be used for various applications. The diï¬€erent types of autoencoders may be modiï¬ed or combined to form new models for various applications. For example, in [39], they are used for classiï¬cation,

Autoencoders

9

captioning, and unsupervised learning. We describe below some of the applications of autoencoders.

4.1 Autoencoders as a generative model
As explained in Section 3, variational autoencoders are generative models that attempt to describe data generation through a probabilistic distribution. Furthermore, as can be seen in Equation 9, the posterior distribution ğ‘ ğœ™ (z|x(ğ‘–) which is derived by the encoder, is regularized towards a continuous and complete distribution in the shape of the predeï¬ned prior of the latent variables ğ‘ ğœƒ (z). Once trained, one can simply samples random variables from the the same prior, and feed it to the decoder. Since the decoder was trained generate x from ğ‘ ğœƒ (xğ‘– |z), it would generate a meaningful newly-generated sample. In ï¬gure 4, original and generated images are displayed over the MNIST dataset. When discussing the generation of new samples, the immediate debate involves the comparison between VAE and GANs. An overview on this can be found at Section 5.1, and two methods that combine both models can be found at Sections 5.2 and 5.3.

(a) Sample from the original MNIST dataset.

(b) VAE generated MNIST images.

Fig. 4: Generated images of from a variational autoencoder, trained on the MNIST dataset with a prior ğ‘ ğœƒ (z) = N (0, I). Left: original images from the dataset. Right: generated images.

4.2 Use of autoencoders for classiï¬cation
While autoencoders are being trained in an unsupervised manner (i.e., in the absence of labels), they can be used also in the semi-supervised setting (where part of the

10

Dor Bank, Noam Koenigstein, Raja Giryes

data do have labels) for improving classiï¬cation results. In this case, the encoder is used as a feature extractor and is "plugged" into a classiï¬cation network. This is mainly done in the semi-supervised learning setup, where a large dataset is given for a supervised learning task, but only a small portion of it is labeled.
The key assumption is that samples with the same label should correspond to some latent presentation, which can be approximated by the latent layer of autoencoders. First, the autoencoders are trained in an unsupervised way, as described in previous sections. Then (or in parallel), the decoder is put aside, and the encoder is used as the ï¬rst part of a classiï¬cation model. Its weights may be ï¬ne tuned [13] or stay ï¬xed during training. A simpler strategy can be found in [17], where a support vector machine (SVM) is trained on the output features of the encoder. In cases where the domain is high dimensional, and the layer-by-layer training is unfeasable, one solution is to train each layer as a linear layer before adding the non linearity. In this case, even with denoising the inputs, there exists a closed form solution for each layer, and no iterative process is needed [9].
Another approach use autoencoders as a regularization technique for a classiï¬cation network. For example, in [29, 60], two networks are connected to the encoder, a classiï¬cation network (trained with the labelled data) and the decoder network (trained to reconstruct the data, whether labeled or unlabeled). Having the reconstruction head in addition to the classiï¬cation head serves a regularizer for the latter. An illustration is given in ï¬gure 5.

4.3 Use of autoencoders for clustering
Clustering is an usupervised problem, where the target is to split the data to groups such that sampless in each group are similar to one another, and diï¬€erent from the samples in the other groups. Most of the clustering algorithms are sensitive to the dimensions of the data, and suï¬€er from the curse of dimensionality.
Assuming that the data have some low-dimensional latent representation, one may use autoencoders to calculate such representations for the data, which are composed of much less features. First, the autoencoder is trained as described in the sections before. Then, the decoder is put aside, similarly to the usage in classiï¬cation. The latent representation (the encoders output) of each data point is then kept, and serves as the input for any given clustering algorithm (e.g., ğ¾-means).
The main disadvantage of using vanilla autoencoders for clustering is that the embeddings are trained solely for reconstruction and not for the clustering application. To overcome this, several modiï¬cations can be made. In [45], the clustering is done similarly to the K-means algorithm [55], but the embeddings are also retrained at each iteration. In this training an argument is added to the autoencoder loss function, which penalizes the distance between the embedding and the cluster center.
In [20], A prior distribution is made on the embeddings. Then, the optimization is done both by the reconstruction error and by the KL-Divergence between the resulting embeddings distribution and the assumed prior. This can be done implicitly,

Autoencoders

11

Fig. 5: An illustration for using autoencoders as regularization for supervised models. Given the reconstruction loss ğ‘…(ğ‘¥, ğ‘¥Ë†), and the classiï¬cation lost function L (ğ‘¦, ğ‘¦Ë†), the new loss function would be LËœ = L (ğ‘¦, ğ‘¦Ë†) +ğœ†ğ‘…(ğ‘¥, ğ‘¥Ë†), where ğœ† is the regularization parameter
.
by training a VAE with the assumed prior. At [10], this is done while assuming a multivariate Gaussian mixture.
4.4 Use of autoencoders for anomaly detection
Anomaly detection is another unsupervised task, where the objective is to learn a normal proï¬le given only the normal data examples and then identify the samples not conforming to the normal proï¬le as anomalies. This can be applied in diï¬€erent applications such as fraud detection, system monitoring, etc. The use of autoencoders for this tasks, follows the assumption that a trained autoencoder would learn the latent subspace of normal samples. Once trained, it would result with a low reconstruction error for normal samples, and high reconstruction error for anomalies [21, 18, 62, 61].

12

Dor Bank, Noam Koenigstein, Raja Giryes

4.5 Use of autoencoders for recommendation systems

A recommender system, is a model or system that seek to predict users preferences or aï¬ƒnities to items [41]. Recommender systems are prominent in e-commerce websites, application stores, online content providers and have many other commercial applications. A classical approach in recommender system models is Collaborative Filtering (CF) [22]. In CF, user preferences are inferred based on information from other user preferences. The hidden assumption is that the human preferences are highly correlated i.e., people that exhibit similar preferences in the past will exhibit similar preferences in the future.
An basic example of the use of autoencoders for recommender systems is the AutoRec model [44]. The AutoRec model has two variants: user-based AutoRec (U-AutoRec) and item-based AutoRec (I-AutoRec). In U-AutoRec the autoencoder learns a lower dimensional representation of item preferences for speciï¬c users while in I-AutoRec, the autoencoder learns a lower dimensional representation of user preferences for speciï¬c items.
For example, assume a dataset consisting of ğ‘€ user and ğ‘ items. Let rm âˆˆ RN be a preference vector for the user ğ‘š consisting of its preference score to each of the ğ‘ items. U-AutoRecoâ€™s decoder is ğ‘§ = ğ‘”(rğ‘š) mapping rğ‘š into representation the representation vector ğ‘§ âˆˆ Rğ‘‘, where ğ‘‘ ğ‘. The reconstruction given the encoder ğ‘“ (ğ‘§) is â„(rğ‘š; ğœƒ) = ğ‘“ (ğ‘”(rğ‘š)), where ğœƒ are the modelâ€™s parameters. The U-AutoRec objective is deï¬ned as

ğ‘€

âˆ‘ï¸ arg minğœƒ

rğ‘š âˆ’ â„(rğ‘š; ğœƒ)

2 + ğœ† Â· ğ‘Ÿğ‘’ğ‘”.
ğ‘‚

(17)

ğ‘š=1

Here, Â· 2 means that the loss is deï¬ned only on the observed preferences of the
ğ‘‚
user. At prediction time, we can investigate the reconstruction vector and ï¬nd items that the user is likely to prefer.
The I-AutoRec is deï¬ned symetrically as follows: Let rğ‘› be item ğ‘›â€™s preference vector for each user. The I-AutoRec objective is deï¬ned as

ğ‘

âˆ‘ï¸ arg minğœƒ

rğ‘› âˆ’ â„(rğ‘›; ğœƒ)

2 + ğœ† Â· ğ‘Ÿğ‘’ğ‘”.
ğ‘‚

(18)

ğ‘›=1

At prediction time, we reconstruct the preference vector for each item, and look for potential users with high predicted preference.
In [47, 46], the basic AutoRec model was extended by including de-noising techniques and incorporating users and items side information such as user demographics or item descriptoin. The de-noising serve as another type of regularization that prevent the auto-encoder overï¬tting rare patterns that do not concur with general user preferences. The side information whas shown to improve accuracy and speed-up the training process.

Autoencoders

13

Similar to the original AutoRec, two symetrical models have been proposed, one that works with user preference rğ‘š vectors and the other with item preference vectors rğ‘›. In the general case, these vectors may consist of explicit ratings. The Collaborative Denoising Auto-Encoder (CDAE) model [59] is essentially applying the same approach on vectors of implicit ratings rather than explicit ratings. Finally, a variational approach have been attempted by applaying VAE in a similar fashion [31].

4.6 Use of autoencoders for dimensionality reduction
Real world data such as text or images is often represented using a sparse highdimensional representation. While many models and applications work directly in the high dimensional space, this often leads to the curse of dimensioanlity [15]. The goal of dimensionality reduction is to learn a a lower dimensional manifold, so-called â€œintrinsic dimensionalityâ€ space.
A classical approach for dimensionality reduction is Principal Component Analysis (PCA) [58]. PCA is a linear projection of data points into a lower dimensional space such that the squared reconstruction loss is minimized. As a linear projection, PCA is optmial. However, non-linear methods such as autoencoders, may and often do achieve superior results.
Other methods for dimensionalty reduction employ diï¬€erent objectives. For example, Linear Discriminant Analysis (LDA) is a supervised method to ï¬nd a linear subspace, which is optimal for discriminating data from diï¬€erent classes [11]. ISOMAP [48] learns a low dimensional manifold by retaining the geodesic distance between pairwise data in the original space. For a survey of diï¬€erent dimensioanlity methods see [51].
The use of autoencoders for dimensionality reduction is stright forward. In fact, the dimensionality reduction is performed by every autoencoder in the bottleneck layer. The projection of the original input into the lower-dimensional bottleneck representation is a dimension reduction operation through the encoder and under the objective given to the decoder. For example, an autoencoder comrised of a simple fully connected encoder and decoder with a squared loss objective performs dimension reduction with a similar objective to PCA. However, the non-linearity activation functions often allows for a superior reconstruction when compared to simple PCA. More complex architectures and diï¬€erent objectives allow diï¬€erent complex dimension reduction models. To review the diï¬€erent applications of autoencoders for dimension reduction, we erefer the interested reader to [24, 56, 57].

14

Dor Bank, Noam Koenigstein, Raja Giryes

5 Advanced autoencoder techniques

Autoencoders are usually trained by a loss function corresponding to the diï¬€erence between the input and the output. As shown above, one of the strengths of autoencoders is the ability to use their latent representation for diï¬€erent usages. On the other hand, by looking at the reconstruction quality of autoencoders for images, one of its major weaknesses becomes clear, as the resulting images are usually blurry. The reason for that is the used loss function, which does not take into account how realistic its results are and does not use the prior knowledge that the input images are not blurred. In recent years, there were some developments related to autoencoders, which deal with this weakness.

5.1 Autoencoders and generative adversarial networks
Variational autoencoders are trained (usually) on MSE which yields slightly blurred images, but allows inference over the latent variables in order to control the output. An alternative generative model to autoencoders that synthesize data (such as images) is the Generative Adversarial Networks (GANs). In a nutshell, a GAN architecture consists of two parts: The generator which generates new samples, and a discriminator which is trained to distinguish between real samples, and generated ones. The generator and the discriminator are trained together using a loss function that enforces them to compete with each other, and by thus improves the quality of the generated data. This leads to generated results that are quite compelling visually, but in the cost of the control on the resulting images. Diï¬€erent works have been done for having the advantages of both models, by diï¬€erent combinations of the architectures and the loss functions. In Adversarial Autoencoders [34], The KL-divergence in the VAE loss function is replaced by a discriminator network that distinguishes between the prior and the approximated posterior. In [28], the reconstruction loss in the VAE loss is replaced by a discriminator, which makes the decoder to essentially merge with the generator. In [14], the discriminator of the GAN is combined with an encoder via shared weights, which enables the latent space to be conveniently modeled by GMM for inference. This approach was then used in [25] for self-supervised learning. We detail next two other directions for combining GANs with autoencoders.

5.2 Adversarially learned inference
One of the disadvantages of GANs is mode collapse, which unlike autoencoders, may cause them to represent via the latent space just part of the data (miss some modes in its distribution) and not all of it.
In Adversarially Learned Inference (ALI) there is an attempt to merge the ideas of both VAEs and GANS, and get a compromise of their strengths and weaknesses

Autoencoders

15

[12]. Instead of training a VAE with some loss function between the input and the output, a discriminator is used to distinguish between (x, zË†) pairs, where x is an input sample and z âˆ¼ ğ‘(z|x) is sampled from the encoders output, and (xËœ, z) pairs, where z âˆ¼ ğ‘(z) is sampled from the used prior in the VAE, and xËœ âˆ¼ ğ‘(x|z) is the decoders output. This way the decoder is enforced to output realistic results in order to "fool" the discriminator. Yet, the autoencoder structure is maintained. An example of how ALI enables altering speciï¬c features in order to get meaningful alterations in images is presented in Figure 6.

Fig. 6: An Image drawn from [12]. A model is ï¬rst trained on the CelebA dataset [33]. It includes 40 diï¬€erent attributes on each image, which in ALI are linearly embedded in the encoder, decoder, and discriminator. Following the training phase, a single ï¬xed latent code ğ‘§ is sampled. Each row has a subset of attributes that are held constant across columns. The attributes are male, attractive, young for row ğ¼; male attractive, older for row ğ¼ ğ¼; female, attractive, young for row ğ¼ ğ¼ ğ¼; female, attractive, older for Row ğ¼ğ‘‰. Attributes are then varied uniformly over rows across all columns in the following sequence: (b) black hair; (c) brown hair; (d) blond hair; (e) black hair, wavy hair; (f) blond hair, bangs; (g) blond hair, receding hairline; (h) blond hair, balding; (i) black hair, smiling; (j) black hair, smiling, mouth slightly open; (k) black hair, smiling, mouth slightly open, eyeglasses; (l) black hair, smiling, mouth slightly open, eyeglasses, wearing hat.
ALI is an important milestone in the goal of merging both concepts and it had many extentions. For example, HALI [5] learns the autoencoder in hierchical structure in order to improve the recostruction ability. ALICE [30] added a conditional entropy loss between the real and the reconstructed images.
5.3 Wasserstein autoencoders
In continuation to Section 5.2, GANs generate compelling images, but do not provide inference, and have a lot of inherent problems regarding its learning stability.

16

Dor Bank, Noam Koenigstein, Raja Giryes

Wasserstein-GAN (WGAN) [1], solves a lot of those problems by using the Wasserstein distance for the optimizations loss function. The Wasserstein distance, is a speciï¬c case of the Optimal Transport distance [52], which is a distance between two probabilities, ğ‘ƒğ‘‹ and ğ‘ƒğº, and is deï¬ned as:

ğ‘Šğ‘ (ğ‘ƒğ‘‹ , ğ‘ƒğº) =

inf

E(ğ‘‹ ,ğ‘Œ )âˆ¼Î“ [ğ‘( ğ‘‹, ğ‘Œ )]

(19)

Î“âˆˆğ‘ƒ (ğ‘‹ âˆ¼ğ‘ƒğ‘‹ ,ğ‘Œ âˆ¼ğ‘ƒğº )

where ğ‘(ğ‘¥, ğ‘¦) is some cost function. When ğ‘(ğ‘¥, ğ‘¦) = ğ‘‘ ğ‘ (ğ‘¥, ğ‘¦) is a metric measurement, then the ğ‘-th root of ğ‘Šğ‘ is called the ğ‘-Wasserstein distance. When ğ‘(ğ‘¥, ğ‘¦) = ğ‘‘ (ğ‘¥, ğ‘¦), then we get to the 1-Wasserstein distance, which is also known as the "Earth Moving Distance" [42] and can be deï¬ned as:

ğ‘Š1 (ğ‘ƒğ‘‹ , ğ‘ƒğº) = sup Eğ‘‹âˆ¼ğ‘ƒğ‘‹ [ ğ‘“ ( ğ‘‹)] âˆ’ Eğ‘Œ âˆ¼ğ‘ƒğº [ ğ‘“ (ğ‘Œ )]

(20)

ğ‘“ âˆˆğ”‰

Unformally, we try to match the two probabilities by "moving" the ï¬rst to the latter in the shortest distance, and that distance is deï¬ned as the 1-Wasserstein distance.
As seen in Equation 9, the loss function of a speciï¬c sample is comprised of the reconstruction error and a regularization factor which enforces the latent representation to resemble the prior (usually multivariate standard normal). The problem addressed in [49], is that this regularization essentially pushes all the samples to look the same, and does not use the entire latent space as a whole. In GANs, the OT distance is used to discriminate between the distribution of real images and the distribution of fake ones. In Wasserstein autoencoders (WAE) [49], the authors modiï¬ed the loss function for autoencoders, which lead to the following objective:

ğ·ğ‘Š

ğ´ğ¸

(ğ‘ƒğ‘‹ ,

ğ‘ƒğº )

=

inf
ğ‘„(ğ‘ |ğ‘‹) âˆˆğ””

Eğ‘ƒğ‘‹ Eğ‘„ (ğ‘ |ğ‘‹)

[ğ‘(ğ‘‹,

ğº(ğ‘))]

+

ğœ†

Â·

ğ·ğ‘

(ğ‘„ğ‘ ,

ğ‘ƒğ‘ ),

(21)

Where ğ‘„ is the encoder and ğº is the decoder. The left part is the new reconstruction loss, which now penalizes on the output distribution and the sample distribution. This is penalization since the "transportation plan" factors through the ğº mapping [7]. The right part penalizes the distance between the latent space distribution to the prior distribution. The authors keep the prior as the multivariate normal distribution, and use to examples for divergences: the Jensen-Shannon divergence ğ· ğ‘— ğ‘  [32], and the maximum mean discrepancy (MMD) [19] Figure 7 illustrates the regularizations diï¬€erence between ğ‘‰ ğ´ğ¸ and ğ‘Š ğ´ğ¸.

5.4 Deep feature consistent variational autoencoder
In this section, a diï¬€erent loss function is presented to optimize the autoencoder. Given an original image and a reconstructed one, instead of measuring some norm on the pixel diï¬€erence (such as the â„“2), a diï¬€erent measure is used that takes into account the correlation between the pixels.

Autoencoders

17

Fig. 7: An Image drawn from [49]. Both VAE and WAE minimize two terms: the reconstruction cost and the regularizer penalizing discrepancy between ğ‘ƒğ‘ and distribution induced by the encoder ğ‘„. VAE forces ğ‘„(ğ‘ |ğ‘‹ = ğ‘¥) to match ğ‘ƒğ‘ for all the diï¬€erent input examples ğ‘¥ drawn from ğ‘ƒğ‘‹ . This is illustrated on picture (a), where every single red ball is forced to match ğ‘ƒğ‘ depicted as the white shape. Red balls start intersecting, which leads to problems with reconstruction. In contrast, WAE forces the continuous mixture ğ‘„ğ‘ := âˆ« ğ‘„(ğ‘ |ğ‘‹)ğ‘‘ğ‘ƒğ‘‹ to match ğ‘ƒğ‘ , as depicted with the green ball in picture (b). As a result latent codes of diï¬€erent examples get a chance to stay far away from each other, promoting a better reconstruction.
Pretrained classiï¬cation networks are commonly used for transfer learning. They allow transcending between diï¬€erent input domains, where the weights of the model, which have been trained for one domain, are ï¬ne tuned for the new domain in order to adapt to the changes between the domains. This can be done by training all the modelsâ€™ (pretrained) weights for several epochs, or just the ï¬nal layers. Another use of pretrained networks is style transfer, where a style of one image is transfered to another image [16], .e.g., causing a regular photo looks like a painting of a given painter (e.g., Van Gogh) while maintaining its content (e.g., keeping the trees, cars, houses, etc. at the same place). In this case, the pretrained networks serve as a loss function.
The same can be done for autencoders. A pretrained network can be used for creating a loss function for autoencoders [26]. After encoding and decoding an image, both the original and reconstructed image are inserted as input to a pretrained network. Assuming the pretrained network results with high accuracy, and the domain which it was trained on is not too diï¬€erent than the one of the autoencoder, then each layer can be seen as a successful feature extractor of the input image. Therefore, instead of measuring the diï¬€erence between the two images directly, it can be measured between their representation in the network layers. By measuring the diï¬€erence between the images at diï¬€erent layers in the network imposes a more realistic diï¬€erence measure for the autoencoder.

18

Dor Bank, Noam Koenigstein, Raja Giryes

5.5 Conditional image generation with PixelCNN decoders

Another alternative proposes a composition between autoencoders and PixelCNN [37]. In PixelCNN [36], the pixels in the image are ordered by some arbitrary order (e.g., top to bottom, left to right, or RGB values). Then the output is formed sequentially where each pixel is a result of both the output of previous pixels, and the input. This strategy takes into account the local spatial statistics of the image, as illustrated in Figure 8. For example, below a background pixel, there is a higher chance to have another background pixel, than the chance of having a foreground pixel. With the use of the spatial ordering (in addition to the input pixel information), the probability of getting a blurred pixel diminishes. In a later development [50], the local statistics was replaced by the usage of an RNN, but the same concept of pixel generation was remained. This concept can be combined with autoencoders by setting the decoder to be structured as a pixelCNN network generating the output image in a sequential order.

Fig. 8: The pixelCNN generation framework. The pixels are generated sequentially. In this case they are generated from top to bottom and from laft to right. The next pixel to be generated is the yellow one. The green pixels are the already generated ones. For generating the yellow pixel, the pixelRNN takes into account the hidden state, and the information of the green pixels in the red square.

Autoencoders

19

6 Conclusion

This chapter presented autoencoders showing how the naive architectures that were ï¬rst deï¬ned for them evolved to powerful models with the core abilities to learn a meaningful representation of the input and to model generative processes. These two abilities can be easily transformed to various use-cases, where part of them were covered. As explained in Section 5.2, one of the autoencoders fall-backs, is that its reconstruction errors do not include how realistic the outputs are. As for modeling generative processes, despite the success of variational and disentangled autoencoders, the way to choose the size and distribution of the hidden state is still based on experimentation, by considering the reconstruction error, and by varying the hidden state at post training. A future research that better sets these parameters is required.
To conclude, the goal of autoencoders is to get a compressed and meaningful representation. We would like to have a representation that is meaningful to us, and at the same time good for reconstruction. In that trade oï¬€, it is important to ï¬nd the architectures which serves all needs.

References
1. Arjovsky, M., Chintala, S., Bottou, L.: Wasserstein generative adversarial networks. In: D. Precup, Y.W. Teh (eds.) Proceedings of the 34th International Conference on Machine Learning, Proceedings of Machine Learning Research, vol. 70, pp. 214â€“223. PMLR, International Convention Centre, Sydney, Australia (2017)
2. Baldi, P.: Autoencoders, unsupervised learning, and deep architectures. In: I. Guyon, G. Dror, V. Lemaire, G. Taylor, D. Silver (eds.) Proceedings of ICML Workshop on Unsupervised and Transfer Learning, Proceedings of Machine Learning Research, vol. 27, pp. 37â€“49. PMLR, Bellevue, Washington, USA (2012)
3. Baldi, P., Hornik, K.: Neural networks and principal component analysis: Learning from examples without local minima. Neural Netw. 2(1), 53â€“58 (1989). DOI 10.1016/0893-6080(89) 90014-2. URL http://dx.doi.org/10.1016/0893-6080(89)90014-2
4. Bank, D., Giryes, R.: An ETF view of dropout regularization. In: 31st British Machine Vision Conference 2020, BMVC 2020, Virtual Event, UK, September 7-10, 2020. BMVA Press (2020). URL https://www.bmvc2020-conference.com/assets/papers/0044.pdf
5. Belghazi, M.I., Rajeswar, S., Mastropietro, O., Rostamzadeh, N., Mitrovic, J., Courville, A.: Hierarchical adversarially learned inference (2018)
6. Bishop, C.M.: Pattern Recognition and Machine Learning (Information Science and Statistics). Springer-Verlag, Berlin, Heidelberg (2006)
7. Bousquet, O., Gelly, S., Tolstikhin, I., Simon-Gabriel, C.J., Schoelkopf, B.: From optimal transport to generative modeling: the vegan cookbook. arXiv (2017)
8. Burda, Y., Grosse, R.B., Salakhutdinov, R.: Importance weighted autoencoders. CoRR abs/1509.00519 (2015)
9. Chen, M., Xu, Z., Weinberger, K., Sha, F.: Marginalized denoising autoencoders for domain adaptation. Proceedings of the 29th International Conference on Machine Learning, ICML 2012 1 (2012)
10. Dilokthanakul, N., Mediano, P.A.M., Garnelo, M., Lee, M.C.H., Salimbeni, H., Arulkumaran, K., Shanahan, M.: Deep unsupervised clustering with gaussian mixture variational autoencoders. ArXiv abs/1611.02648 (2017)

20

Dor Bank, Noam Koenigstein, Raja Giryes

11. Duda, R.O., Hart, P.E., Stork, D.G., et al.: Pattern classiï¬cation. International Journal of Computational Intelligence and Applications 1, 335â€“339 (2001)
12. Dumoulin, V., Belghazi, I., Poole, B., Lamb, A., Arjovsky, M., Mastropietro, O., Courville, A.C.: Adversarially learned inference. ArXiv abs/1606.00704 (2016)
13. Erhan, D., Bengio, Y., Courville, A., Manzagol, P.A., Vincent, P., Bengio, S.: Why does unsupervised pre-training help deep learning? J. Mach. Learn. Res. 11, 625â€“660 (2010)
14. Feigin, Y., Spitzer, H., Giryes, R.: Gmm-based generative adversarial encoder learning (2020) 15. Friedman, J.H.: On bias, variance, 0/1â€”loss, and the curse-of-dimensionality. Data mining
and knowledge discovery 1(1), 55â€“77 (1997) 16. Gatys, L.A., Ecker, A.S., Bethge, M.: Image style transfer using convolutional neural networks.
2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR) pp. 2414â€“2423 (2016) 17. Gogoi, M., Begum, S.A.: Image classiï¬cation using deep autoencoders. In: 2017 IEEE International Conference on Computational Intelligence and Computing Research (ICCIC), pp. 1â€“5 (2017). DOI 10.1109/ICCIC.2017.8524276 18. Gong, D., Liu, L., Le, V., Saha, B., Mansour, M.R., Venkatesh, S., van den Hengel, A.: Memorizing normality to detect anomaly: Memory-augmented deep autoencoder for unsupervised anomaly detection (2019) 19. Gretton, A., Borgwardt, K.M., Rasch, M.J., SchÃ¶lkopf, B., Smola, A.: A kernel two-sample test. J. Mach. Learn. Res. 13(null), 723â€“773 (2012) 20. Guo, X., Liu, X., Zhu, E., Yin, J.: Deep clustering with convolutional autoencoders. pp. 373â€“382 (2017) 21. Hasan, M., Choi, J., Neumann, J., Roy-Chowdhury, A.K., Davis, L.S.: Learning temporal regularity in video sequences. In: 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), pp. 733â€“742 (2016) 22. Herlocker, J.L., Konstan, J.A., Riedl, J.: Explaining Collaborative Filtering Recommendations. In: Proceedings of the 2000 ACM Conference on Computer Supported Cooperative Work, CSCW â€™00, pp. 241â€“250. ACM (2000) 23. Higgins, I., Matthey, L., Pal, A., Burgess, C., Glorot, X., Botvinick, M.M., Mohamed, S., Lerchner, A.: beta-vae: Learning basic visual concepts with a constrained variational framework. In: ICLR (2017) 24. Hinton, G.E., Salakhutdinov, R.R.: Reducing the dimensionality of data with neural networks. science 313(5786), 504â€“507 (2006) 25. Hochberg, D.C., Giryes, R., Greenspan, H.: A self supervised stylegan for classiï¬cationwith extremely limited annotations (2021) 26. Hou, X., Shen, L., Sun, K., Qiu, G.: Deep feature consistent variational autoencoder. CoRR abs/1610.00291 (2016). URL http://arxiv.org/abs/1610.00291 27. Kingma, D.P., Welling, M.: Auto-encoding variational bayes. CoRR abs/1312.6114 (2013) 28. Larsen, A.B.L., SÃ¸nderby, S.K., Larochelle, H., Winther, O.: Autoencoding beyond pixels using a learned similarity metric. In: Proceedings of the 33rd International Conference on International Conference on Machine Learning - Volume 48, ICMLâ€™16, p. 1558â€“1566. JMLR.org (2016) 29. Le, L., Patterson, A., White, M.: Supervised autoencoders: Improving generalization performance with unsupervised regularizers. In: S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, R. Garnett (eds.) Advances in Neural Information Processing Systems 31, pp. 107â€“117. Curran Associates, Inc. (2018) 30. Li, C., Liu, H., Chen, C., Pu, Y., Chen, L., Henao, R., Carin, L.: Alice: Towards understanding adversarial learning for joint distribution matching. In: I. Guyon, U.V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, R. Garnett (eds.) Advances in Neural Information Processing Systems, vol. 30. Curran Associates, Inc. (2017). URL https://proceedings. neurips.cc/paper/2017/file/ade55409d1224074754035a5a937d2e0-Paper.pdf 31. Liang, D., Krishnana, R.G., Hoï¬€man, M.D., Jebara, T.: Variational autoencoders for collaborative ï¬ltering. CoRR abs/1802.05814 (2018). URL https://arxiv.org/abs/1802.05814

Autoencoders

21

32. Lin, J.: Divergence measures based on the shannon entropy. IEEE Transactions on Information Theory 37(1), 145â€“151 (1991). DOI 10.1109/18.61115. URL http://ieeexplore.ieee. org/xpl/articleDetails.jsp?arnumber=61115
33. Liu, Z., Luo, P., Wang, X., Tang, X.: Deep learning face attributes in the wild. In: Proceedings of the 2015 IEEE International Conference on Computer Vision (ICCV), ICCV â€™15, p. 3730â€“3738. IEEE Computer Society, USA (2015). DOI 10.1109/ICCV.2015.425. URL https://doi. org/10.1109/ICCV.2015.425
34. Makhzani, A., Shlens, J., Jaitly, N., Goodfellow, I.J.: Adversarial autoencoders. CoRR abs/1511.05644 (2015)
35. Masci, J., Meier, U., CireÅŸan, D., Schmidhuber, J.: Stacked convolutional auto-encoders for hierarchical feature extraction. In: T. Honkela, W. Duch, M. Girolami, S. Kaski (eds.) Artiï¬cial Neural Networks and Machine Learning â€“ ICANN 2011, pp. 52â€“59. Springer Berlin Heidelberg, Berlin, Heidelberg (2011)
36. van den Oord, A., Kalchbrenner, N., Kavukcuoglu, K.: Pixel recurrent neural networks (2016) 37. Oord, A.v.d., Kalchbrenner, N., Vinyals, O., Espeholt, L., Graves, A., Kavukcuoglu, K.: Con-
ditional image generation with pixelcnn decoders. In: Proceedings of the 30th International Conference on Neural Information Processing Systems, NIPSâ€™16, pp. 4797â€“4805. Curran Associates Inc., USA (2016). URL http://dl.acm.org/citation.cfm?id=3157382. 3157633 38. Plaut, E.: From principal subspaces to principal components with linear autoencoders (2018) 39. Pu, Y., Gan, Z., Henao, R., Yuan, X., Li, C., Stevens, A., Carin, L.: Variational autoencoder for deep learning of images, labels and captions. In: Advances in Neural Information Processing Systems 29: Annual Conference on Neural Information Processing Systems 2016, December 5-10, 2016, Barcelona, Spain, pp. 2352â€“2360 (2016) 40. Ranzato, M., Huang, F.J., Boureau, Y., LeCun, Y.: Unsupervised learning of invariant feature hierarchies with applications to object recognition. In: 2007 IEEE Conference on Computer Vision and Pattern Recognition, pp. 1â€“8 (2007). DOI 10.1109/CVPR.2007.383157 41. Ricci, F., Rokach, L., Shapira, B.: Introduction to recommender systems handbook. In: Recommender systems handbook, pp. 1â€“35. Springer (2011) 42. Rubner, Y., Tomasi, C., Guibas, L.: The earth moverâ€™s distance as a metric for image retrieval. International Journal of Computer Vision 40, 99â€“121 (2000). DOI 10.1023/A:1026543900054 43. Rumelhart, D.E., Hinton, G.E., Williams, R.J.: Parallel distributed processing: Explorations in the microstructure of cognition, vol. 1. chap. Learning Internal Representations by Error Propagation, pp. 318â€“362. MIT Press, Cambridge, MA, USA (1986). URL http://dl.acm. org/citation.cfm?id=104279.104293 44. Sedhain, S., Menon, A.K., Sanner, S., Xie, L.: Autorec: Autoencoders meet collaborative ï¬ltering. In: Proceedings of the 24th International Conference on World Wide Web Companion, WWW 2015, Florence, Italy, May 18-22, 2015 - Companion Volume, pp. 111â€“112 (2015) 45. Song, C., Liu, F., Huang, Y., Wang, L., Tan, T.: Auto-encoder based data clustering. In: J. Ruiz-Shulcloper, G. Sanniti di Baja (eds.) Progress in Pattern Recognition, Image Analysis, Computer Vision, and Applications, pp. 117â€“124. Springer Berlin Heidelberg, Berlin, Heidelberg (2013) 46. Strub, F., Mary, J.: Collaborative Filtering with Stacked Denoising AutoEncoders and Sparse Inputs. In: NIPS Workshop on Machine Learning for eCommerce. Montreal, Canada (2015) 47. Strub, F., Mary, J., Gaudel, R.: Hybrid recommender system based on autoencoders. CoRR abs/1606.07659 (2016). URL http://arxiv.org/abs/1606.07659 48. Tenenbaum, J.B., De Silva, V., Langford, J.C.: A global geometric framework for nonlinear dimensionality reduction. science 290(5500), 2319â€“2323 (2000) 49. Tolstikhin, I., , Bousquet, O., Gelly, S., Scholkopf, B.: Wasserstein auto-encoders. ICML 2018 (2018) 50. Van Den Oord, A., Kalchbrenner, N., Kavukcuoglu, K.: Pixel recurrent neural networks. In: Proceedings of the 33rd International Conference on International Conference on Machine Learning - Volume 48, ICMLâ€™16, p. 1747â€“1756. JMLR.org (2016) 51. Van Der Maaten, L., Postma, E., Van den Herik, J.: Dimensionality reduction: a comparative review. J Mach Learn Res 10, 66â€“71 (2009)

22

Dor Bank, Noam Koenigstein, Raja Giryes

52. Villani, C.: Topics in Optimal Transportation. Graduate studies in mathematics. American Mathematical Society (2003). URL https://books.google.co.il/books?id= GqRXYFxe0l0C
53. Vincent, P., Larochelle, H., Bengio, Y., Manzagol, P.A.: Extracting and composing robust features with denoising autoencoders. In: Proceedings of the 25th International Conference on Machine Learning, ICML â€™08, pp. 1096â€“1103. ACM, New York, NY, USA (2008). DOI 10.1145/1390156.1390294. URL http://doi.acm.org/10.1145/1390156.1390294
54. Vincent, P., Larochelle, H., Lajoie, I., Bengio, Y., Manzagol, P.A.: Stacked denoising autoencoders: Learning useful representations in a deep network with a local denoising criterion. J. Mach. Learn. Res. 11, 3371â€“3408 (2010). URL http://dl.acm.org/citation.cfm?id= 1756006.1953039
55. Wagstaï¬€, K., Cardie, C., Rogers, S., SchrÃ¶dl, S.: Constrained k-means clustering with background knowledge. In: Proceedings of the Eighteenth International Conference on Machine Learning, ICML â€™01, p. 577â€“584. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA (2001)
56. Wang, W., Huang, Y., Wang, Y., Wang, L.: Generalized autoencoder: A neural network framework for dimensionality reduction. In: Proceedings of the IEEE conference on computer vision and pattern recognition workshops, pp. 490â€“497 (2014)
57. Wang, Y., Yao, H., Zhao, S.: Auto-encoder based dimensionality reduction. Neurocomputing 184, 232â€“242 (2016)
58. Wold, S., Esbensen, K., Geladi, P.: Principal component analysis. Chemometrics and intelligent laboratory systems 2(1-3), 37â€“52 (1987)
59. Wu, Y., DuBois, C., Zheng, A.X., Ester, M.: Collaborative denoising auto-encoders for top-n recommender systems. In: Proceedings of the Ninth ACM International Conference on Web Search and Data Mining, San Francisco, CA, USA, February 22-25, 2016, pp. 153â€“162 (2018)
60. Zhang, Y., Lee, K., Lee, H.: Augmenting supervised neural networks with unsupervised objectives for large-scale image classiï¬cation. In: Proceedings of the 33rd International Conference on International Conference on Machine Learning - Volume 48, ICMLâ€™16, p. 612â€“621. JMLR.org (2016)
61. Zhao, Y., Deng, B., Shen, C., Liu, Y., Lu, H., Hua, X.S.: Spatio-temporal autoencoder for video anomaly detection. In: Proceedings of the 25th ACM International Conference on Multimedia, MM â€™17, p. 1933â€“1941. Association for Computing Machinery, New York, NY, USA (2017). DOI 10.1145/3123266.3123451. URL https://doi.org/10.1145/3123266.3123451
62. Zong, B., Song, Q., Min, M.R., Cheng, W., Lumezanu, C., ki Cho, D., Chen, H.: Deep autoencoding gaussian mixture model for unsupervised anomaly detection. In: ICLR (2018)

